[toc]

# Unity architecture

## .NET in Unity
### .NET配置文件支持
### 稳定脚本运行时：已知限制
### 自动内存管理
- Unity 的 Mono 引擎等运行时系统会自动为您管理内存
- 创建对象、字符串或数组时，用于存储它的内存是从称为堆的中央池分配的。当此项不再使用时，其先前占用的内存可被回收并用于其他目的。
#### Unity的值类型||引用类型 
-  Unity 的结构类型（例如，__Color__ 和 __Vector3__）是值类型
#### unity的GC使用的是2种方式(标记清楚、引用计数)的哪一个？
#### GC的优化 (GC需要好的使用)
- 垃圾收集是自动完成的，对程序员来说不可见，但收集过程实际上在__后台需要耗费大量 CPU 时间__。
	- 如果使用得当，自动内存管理通常在整体性能上能达到或超过手动分配。
		- 但是，程序员必须避免错误以免导致不必要的频繁触发垃圾回收器并在执行中引起暂停。
##### 不良使用 + GC -> 糟糕的结果
- 有一些臭名昭着的算法虽然一眼看上去好像是无辜的，但可能成为 GC 的噩梦
	- 1. 他们会快速产生源源不断地垃圾
1. 重复的字符串连接
2. 在会被大量调用的函数内使用new分配内存
##### GC下应避免出现的操作

#### 禁用GC
1. 好处：降低CPU的使用率
	- 如果使用的是 Mono 或 IL2CPP 脚本后端，则可以通过在运行时禁用垃圾收集来避免垃圾收集期间的 CPU 使用率激增。
2. 坏处： 因为垃圾回收器不会收集不再有任何引用的对象，垃圾只会逐渐增多

#### GC的使用策略
- 最好尽量避免内存分配。但是，鉴于无法完全消除这些行为，可采用两种主要策略来__最小化这些行为对游戏运行过程的干扰__：
##### 快速和频繁进行垃圾收集的小堆
##### 慢速但不频繁进行垃圾收集的大堆
##### 可重用的对象池
##### unity的GC的小堆和大堆的思想 is like JVM的堆的新生代||老生代的设计思想

### 引用其他类库程序集
### C#编译器


## Scripting backends
### IL2CPP
### 脚本限制
### 托管代码剥离
- 托管代码剥离将从构建中删除未使用的代码，从而可以显著减小最终构建大小。
	- 使用 IL2CPP 脚本后端时，托管代码剥离还可以减少构建时间，因为需要转换为 C++ 并进行编译的代码减少。
- 托管代码剥离将从托管程序集（包括从项目中的 C# 脚本构建的程序集、包含在包和插件中的程序集以及 .NET 框架中的程序集）中删除代码。
#### 托管代码剥离工作方式
- 托管代码剥离的工作方式是对项目中的代码进行__静态分析__，检测出在执行过程中永远无法访问的__类__、__类成员__甚至__函数的某些部分__
	- 可以通过 Player Settings 窗口中的 Managed Stripping Level 设置（在 Optimization 部分）来控制 Unity 删除无法访问的代码的激进程度。
	- __重要信息：__当代码（或插件中的代码）使用反射来动态查找类或成员时，代码剥离工具不能总是检测出项目是否正在使用这些类或成员，因此可能会删除它们。
		- 要声明某个项目正在使用这样的代码，请使用 link.xml 文件或 Preserve 属性。
#### 托管剥离级别
- 使用项目的 Player Settings 中的 Managed Stripping Level 选项来控制 Unity 删除未使用代码的激进程度。
#### 托管代码剥离工作原理

## Code reloading in the Unity Editor
### 可配置的进入运行模式
### 启动时运行Editor脚本代码
## 脚本序列化
### 内置序列化
### 自定义序列化
### 脚本序列化错误
### JSON序列化
## Script compilation
### 特殊文件夹
- 通常可为创建的文件夹选择任何名称来组织 Unity 项目。
- Unity 保留了一些项目文件夹名称来指示内容具有特殊用途
	- Unity 会将许多文件夹名称解释为应以特殊方式处理文件夹内容的指令。
	- 例如，必须将 Editor 脚本放在名为 Editor 的文件夹中才能使这些脚本正常工作。
	[特殊文件夹名称官方文档](https://docs.unity3d.com/cn/current/Manual/SpecialFolders.html)
#### Assets
- Assets 文件夹是包含 Unity 项目使用的资源的主文件夹。
- Editor 中的 Project 窗口的内容直接对应于 Assets 文件夹的内容。
	- 具备实时同步更改功能，在一端(add,delete,)另一端也进行相应的改变
- 大多数 API 函数都假定所有内容都位于 Assets 文件夹中，因此不要求显式提及该文件夹。但是，有些函数需要将 Assets 文件夹作为路径名的一部分添加（例如，AssetDatabase 类中的一些函数）。
#### Editor
- 放在名为 Editor 的文件夹中的脚本被视为 __Editor 脚本__而不是__运行时脚本__。
	- 这些脚本在开发期间向 Editor 添加功能，并在运行时在构建中不可用。
- 可在 Assets 文件夹中的任何位置添加多个 Editor 文件夹。
	- 应将 Editor 脚本放在 Editor 文件夹内或其中的子文件夹内。
- 如果脚本位于 Editor 文件夹中，Unity 不允许将派生自 MonoBehaviour 的组件(脚本组件)分配给游戏对象。
#### Editor Default Resources
#### Gizmos
#### Plug-ins
#### Resources
#### Standard Assets
#### StreamingAssets
#### 隐藏的资源
### 脚本编译顺序
- 特殊文件夹名称会影响脚本编译的顺序。
#### 预定义的程序集
- Unity 根据脚本文件在项目文件夹结构中的位置，以__四个不同的阶段编译脚本__。
	- Unity 为每个阶段创建一个单独的 CSharp 项目文件 (.csproj) 和一个预定义的程序集。
	- 如果没有符合编译阶段的脚本，Unity 不会创建相应的项目文件或程序集。

- 四个阶段的编译顺序
	- 1. 
	- 2. 
	- 3. 
	- 4. 
	- 注意：Standard Assets 仅在 Assets 根文件夹中有效。
- 编译顺序很重要
	- 当脚本引用在不同阶段编译的类（因此位于不同的程序集中）时，编译顺序很重要
	- 脚本引用的基本规则：
		- 1. 前面阶段不能引用后面阶段的：
			- 无法引用在当前阶段之后的阶段编译的任何内容
		- 2. 后面阶段的可以引用前面的：
			- 在当前阶段或早期阶段编译的所有内容则是完全可用的。

#### 自定义程序集文件
- 可以创建__程序集定义文件(.asmdef文件)__，从而使用自己的程序集来组织项目中的脚本。
- 使用程序集定义文件(.asmdef文件)来管理项目的好处：
	- 可以减少在进行不相关的代码更改时需要重新编译的代码量
	- 并可提供对其他程序集的依赖性的更多控制

##### 程序集定义文件is什么
- 可使用程序集定义文件根据文件夹中的脚本来__定义您自己的托管程序集__。
	- 请将项目脚本分成具有明确定义的依赖项的多个程序集
		- 以确保在脚本中进行更改时仅重新构建所需的程序集。这样可以减少编译时间。
- 应将每个__托管程序集__视为 Unity 项目中的__单个库__。

##### how use 程序集定义文件

- 将一个程序集定义文件添加到 Unity 项目中的某个文件夹，即可将该文件夹中的所有脚本编译为一个程序集。
- 

### 平台相关的编译

#### Scripting Define Symbols 
- why要使用Scripting Define Symbols ？？能带给我们什么
- 相当于C中的预编译相关的宏？？
- 用来指示预编译器如何预编译代码？？
##### Unity自带的Scripting Define Symbols 
- 位于.rsp文件下？
##### 自定义Scripting Define Symbols 
###### 平台自定义 #define 指令
- 打开 Player Settings 的 Other Settings 面板，并导航到 Scripting Define Symbols 文本框。
- 输入要为该特定平台定义的符号名称，以分号分隔。
- 随后可以将这些符号用作 #if 指令中的条件，就像内置条件一样。
###### 全局自定义 #define 指令
- 您可以定义自己的预处理器指令来控制在编译时包含的代码。
	- 为此，必须将包含额外指令的文本文件添加到 Assets 文件夹。文件名取决于您使用的语言，扩展名为 __.rsp__
		- 举例来说，如果在 mcs.rsp 文件中包含单行 -define:UNITY_DEBUG，则 #define 指令 UNITY_DEBUG 将作为 C# 脚本的全局 #define 指令存在，但 Editor 脚本除外。

- 1. 使用PlayerSetting方式
	- 如果只想修改全局 #define 指令，请使用 Player 设置中的 Scripting Define Symbols__，因为此选项涵盖了所有编译器。
- 2. 使用.rsp__ 文件方式：
	- 如果选择 .rsp__ 文件，则需要为 Unity 使用的每个编译器提供一个文件。

#### 使用Scripting Define Symbols 
- 是不是C#支持的预编译指令均可以使用？？？
- 一般使用这个做什么？？
	- 对同一份代码依据不同平台进行不同的处理？
		- 如：不同平台使用不同的程序集
##### 通过#define来使用

##### 通过 #if #elif #else #endif来使用
- 可以在函数内使用，而#define必须在头部使用

### Assembly definitions(程序集定义)



