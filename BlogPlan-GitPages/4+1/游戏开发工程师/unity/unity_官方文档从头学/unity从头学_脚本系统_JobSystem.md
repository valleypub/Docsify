[toc]

# C# Job System
1. 借助 Unity C# 作业系统，您可以编写简单安全的多线程代码来__与 Unity 引擎进行交互__以提高游戏性能

2. 可将 __C# 作业系统__与 __Unity 实体组件系统 (ECS) __结合使用，通过这种架构可轻松为所有平台创建高效的机器代码。

## C# Job System概述
1. 专为编写多线程代码
2. 将 __Burst 编译器__与 __C# 作业系统__配合使用可以提高代码生成质量，还可以__大大降低移动设备的电池消耗__。
3. C# 作业系统的一个重要特点是它与 Unity 内部使用的系统（Unity 的原生作业系统）相集成。
	- 用户编写的代码与 Unity 共享工作线程
	- 此协作避免了创建超过 CPU 核心数的线程（这种情况会导致争用 CPU 资源）
		- 线程数多于 CPU 核心数会导致线程相互竞争 CPU 资源，进而造成频繁的__上下文切换__
		- 上下文切换是__资源密集型的过程__，因此应尽可能避免

[Unity at GDC - Job System & Entity Component System](https://www.youtube.com/watch?v=kwnb9Clh2Is&list=RDCMUCG08EqOAXJk_YXPDsAvReSg&start_radio=1&t=8s)

## 你真的理解多线程吗

- 多线程是一种编程方式，利用了 CPU 在多个核心上同时处理多个线程的能力

### 主线程
- 默认情况下，在程序的开头会运行一个线程，这就是“主线程”。
- 主线程会创建新线程来处理任务。这些新线程并行运行，通常在完成后将其结果与主线程同步(过程中也可以，数据是共享的)。

### 线程池
- 如果线程的数目很多、线程的生命周期又都很短 -> 这种情况下可能会挑战 CPU 和操作系统处理能力的极限。
	- 设置一个__线程池__可以缓解__线程生命周期__的问题。
	- 但是，即使使用线程池，也可能会同时激活大量线程。 线程数多于 CPU 核心数会导致线程相互竞争 CPU 资源，进而造成__频繁的上下文切换__。
		- 使用unity的__C#作业系统__来直接避免上下文切换


## 作业系统
### 作业系统概述
- 作业系统通过__创建作业__而不是线程来管理多线程代码。

- 作业系统__跨多个核心__管理一组工作线程。
	- 此系统通常每个逻辑 CPU 核心对应一个工作线程，这样可以__避免上下文切换__（但可能会为操作系统或其他专用应用程序保留一些核心）。

- 作业系统将作业放入作业队列中以待执行。作业系统中的工作线程从作业队列中获取并执行所需项。作业系统会管理__依赖关系__并确保作业以适当的顺序执行。

- Unity的作业系统is安全的
	- Unity C# 作业系统可以检测所有潜在的竞争条件，并尽量避免可能导致的错误
### 作业
- 一般通用定义(wiki中)：
	- 一个作业是完成一项特定任务的一个小工作单位。
	- 作业会接收参数并对数据进行操作，其行为方式类似于方法调用。
	- 作业可以是独立的，也可依赖其他作业完成之后才能运行。
- Unity中的“作业”是 Unity 中对于任何__实现 IJob 接口__的结构的统称。

### 作业依赖关系

- 在复杂的系统中，如游戏开发所需的系统中，不太可能每个作业都是独立的，一个作业通常会为下一个作业准备数据。
- 作业知道并支持使系统顺利运转的依赖关系。 
	- 如果 jobA 依赖于 jobB，作业系统将确保 jobA 不会在 jobB 完成之前开始执行。
		- unity是采用__JobHandle__ 来实现的
			- 可以在代码中使用 JobHandle 作为其他作业的依赖项。如果一个作业依赖于另一个作业的结果，则可以将第一个作业的 JobHandle 作为参数传递给第二个作业的 Schedule 方法


### C#作业系统is安全的
#### 竞争条件
1. 编写多线程代码时，__总是存在__出现竞争条件的风险
	- 当一个操作的输出取决于不受其控制的另一个过程的时序时，即出现竞争条件
2. 竞争条件__并不总是错误__，但它是不确定行为的根源。
	- 当竞争条件确实会导致错误时，可能很难找到问题的根源
		- 1. 因为这种情况__取决于时序__，所以只有在极少数情况下可以复现问题。
		- 2. 对此情况进行调试可能会导致问题消失，因为断点和日志记录可能会改变各个线程的时序。
3. 竞争条件是编写多线程代码时遭遇的最大挑战。

#### Unity的安全作业系统
- Unity C# 作业系统可以检测所有潜在的竞争条件，并尽量避免可能导致的错误。

##### 安全作业系统的实现原理
1. 隔离数据，从而消除竞争条件
	- 1. 数据引用 -> 复制数据副本
		- 如果 C# 作业系统将主线程中对代码数据的引用发送给一个作业，则系统无法验证主线程在读取数据的同时是否该作业正在写入数据。这种情况下便会产生竞争条件。
			- C# 作业系统解决这个问题的方法是__向每个作业发送其需要操作的数据的副本，而不是对主线程中的数据进行引用__。此副本可以隔离数据，从而消除竞争条件。


## use作业系统
### 创建作业
### 调度作业
### 