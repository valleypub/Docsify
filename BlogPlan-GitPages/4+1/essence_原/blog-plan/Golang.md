[toc]


# index

## 总的一门语言的核心
![总关系图]()

## Golang的特点

- 1. 不用；  只有一行出现多个语句才用;分隔
- 2. 类型名后置
- 3. 变量可以函数体外声明，却不可体外初始化  why??
- 4. 无pow()求幂函数，要自己写
- 5. 使用标识符的首字母的大、小写(可见、不可见)来设置访问限制  只有可见、不可见两种？？？(c#中有五种、C++有3中)
- 6. 不支持隐式类型转换--必须显式转换----   int(0.05)   typeName( variableName );
- 7. 函数不支持 可选参数 和 默认参数
- 

# 关键字

## var && const

## type
- 1. 像 c/c++中的 typedef , 但又不太一样
- 2. type  新数据类型A  基于的数据类型B  (注意这两个类型不是同一个，虽然)
- 3. type 别名 = 数据类型             （和C/C++中的typedef一样）
- 4. 自定义类型上追加方法：
- 只有自定义类型上可以用下面的方式添加方法，基础数据类型(int,string等不可以)
- 每一个接受其类型名声明的变量 均可以 调用 下面的方法 func   ==   实现了给对象添加方法
```
func (接受器名 接收器类型名) 方法名(参数列表){
		//
}
```


## range

## defer && panic && recover


# 类型
- 类型的关系
![]()


## 类型

- 1. Go中没有class的概念，用struct来代替
- 2. Go的设计者们觉得，类设计的太复杂了，不够简洁
- 
### 3种简单类型
#### string(值类型)
- 1. utf-8
- 2. " "内转义字符有效，‘ ’内转义字符无效
- 3. printf(" ") 内 通用占位符
```

```
- 4. 
#### 数值类型

#### bool

### 复合数据类型
#### struct
- go语言的struct没有构造函数
- 给每个字段隐式初始化为对应类型的零值     字段能不能显式初始化？？
##### 声明struct
##### 初始化struct
- 4中不同的初始化方式：
- 1. 

### 值类型

### 引用类型

### 使用类型
#### 变量声明(must have)
#### 变量初始化(有下面2种)
##### 隐式初始化
- 1. 每种类型的零值
- 2. 不同类型的零值不同：
```

```
##### 显式初始化


## 类型转换

## 泛型

# op

# 流程控制语句
## 顺序

## 分支
### 二分支 if-else
- if else语句可以嵌套

### 多分支 switch case
- 1. fallthrough进行单层case语句穿透；(碰到fallthrough,不管下一个case是不是匹配都会执行) ；如果想穿透多层，在每个想穿透的case前使用fallthrough

```
switch ss {
case 1:{
           //code here
           fallthrough
}
case 3: {
}
          //
          fallthrough
}
```

- 2. case 后面可带多个表达式，使用逗号分隔
```
switch m{
case 1,2,3:{

}

case 4,5,6,7,8,9:{
}

}
```

- 3. default语句不是必须的
- 4. switch 可省略判断条件  此时退化为if else

## 循环
- go中只支持for一种循环


## 跳转
### break
### continue
### goto
### return


# 函数
## 一个函数的组成

<img src="C:\Users\king-kong\Desktop\essence\blog-plan\函数.png" alt="hanshudesibufen" style="zoom:50%;" />

### func
### 函数名

### 输入参数列表

### 返回值类型


## 函数中的变量存储&&编译器优化
### stack && heap的区别
- 1. stack:

```
1. 局部变量
1. 存储单元连续 -> 快
2. 不会碎片化  由于栈的使用机制(后入先出)，只要不栈溢出，一定是入躲闪出多少，不用手动回收
3. 栈溢出

```

- 2. heap:

```
1. 支持动态内存分配
2. 用来存储 全局变量 or 大对象
3. 会碎片化 -> 垃圾回收机制(如果语言支持的话) or 手动清理(c/c++)
4. 内存泄漏问题
5. 非连续 -> 慢
```

### 逃逸分析(判断哪些变量分配在栈上、那些分配在堆上)
- -gcflags参数
- -m	打印出逃逸分析的优化策略 ； 可以同时连用多个 -m -m
- -l	禁用函数的内联功能（inline） 能更好的观察逃逸情况，why???
- 用法： go build -gcflags " -l -m" .\main.goo

### G编译器的存储变量的分配策略(stack or heap)

- stack：局部变量 分配到 
- heap:  1. 无法确定函数返回后有没有其他对象引用的变量	\
		2.变量非常大
		3.变量的大小无法确定(ru: interface{})

## inline内联 && 函数调用 && 递归
- 1. inline is 重写 不是函数调用(if 重写的代价 < 函数调用的开销(入栈等))
- 2. 函数调用笔的函数叫调用，调用自身叫递归

### 如何将非递归 -> 递归

### 如何将递归 -> 非递归方式
- 1. 用循环代替递归
- 

## 回调函数 && 异步


## 闭包

## defer关键字


# 指针
## 内存地址
- 1. 一般计算机中运行的进程使用的地址是虚拟内存地址，经过os翻译到真实的物理地址
- 2. 

## 指针
- 1. go的指针和C的指针看着一样，&变量名 来使用，但是比C的限制多
- 2. 不能对  const常量 、各类型的字面值 、 地址  ， 进行取地址操作  如： &(&a)   (因为&a相当于是一个地址类型的字面值)
- 3. ```var 指针名 *类型名  = 初始化值``` or ```指针名 := 地址值```使用类型推断的方式
- 4. 可以使用 new 创建指针类型 ```var 指针名 := new(类型)```  new会开辟一块内存、并将地址值返给 指针名、刚开辟的内存存放的初始化的  *指针名 = 该类型的零值
- 5. 不能对地址取地址，但是可以对地址变量取地址  ---> 指针的指针 ,或 指针的指针的...指针(多级嵌套)  ``` ```
- 6. 指针、切片、映射、信道、接口、函数的 零值 is   nil
```
1. nil 不能比较
2. nil 没有默认类型
3. all 类型的指针的nil值 is 0x0;
```
- 7. 

## unsafe包
- 1. go中不允许直接对不同类型的指针进行转换，必须使用unsafe包中的功能unsafe.Pointer()函数
- 2. 指针类型1 --> unsafe.Pointer() --> *ArbitaryType --> 再强制转换 
```
	var	a int32 = 0
	var f float64
	int32ptr := new(int32)
	int32ptr = (*int32)(unsafe.Pointer(&f))
	
```

- 3. 借助unsafe可以对struct中的私有字段进行修改
```

```

### 指针的指针

# 错误处理机制

- 没有JAVA中的try...catch...finally
- 使用 defer + panic + recover
- 
