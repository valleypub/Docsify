[toc]

# trivals
## 标识符命名规则
- 驼峰式

## 关键字||保留字||直接量

## 类型的一种划分(按值的存储-解析方式)
### 值存储的本质&&值类型转换
- 虽然所有类型在内存中存储时都是二进制序列(01 + 二进制的长度(bit数)，每8bit(Byte)为一个基元)，但是不同的类型对于同一串二进制序列的解析机制是不一样的。

- 不同类型的值虽然在内存中都是定长的01序列，但是实际的值意义(现实生活中的意义：ru：10，10.5，‘k’，true)与01二进制序列之间的解析机制是不同的
	- 不仅数值类型和非数值类型的不同，数值类型之间也是不同的
	- 字符类型
		- ASCII表映射转换
		- Unicode表映射
			- UTF-8
			- UTF-16
	- 数值类型
		- 整数类型
			- 按数学中的10进制与2进制的代数转换机制来转换
				如：1 -- 00000001  3 -- 00000011
			- 为了实现正数和负数的统一  --> 使用补码的机制
				- 使用补码机制，正数负数的算术运算( + - )在补码域下能实现统一
		- 浮点类型
			- 使用的是 分段 + e指数的 转换方式
		- decimal类型(C#)
			- decimal 类型的范围较小，但精度高于 double
				- 因为和浮点数的转换机制不同？？

- 一般编程语言is__使用二进制序列为中继__来对值进行类型转换
	- 不同数值类型之间的类型转换：
	- 数值类型&&字符类型之间的转换：

### 数值类型
- 用来表示所有的数字
- 浮点型(float ，double，)和整形(byte short int long)的
#### 数值类型的精度和限制
- 数值类型不同于数学上的数值的一点是，程序中的数值类型有精度和限值
	- 限值存在的原因：
		- 数值类型的bit的长度是固定的 ->01的组合情况有限 -> 不可能一一对应所有的自然值，只能对应一个区间段
	- 查看限值的方法：
		- C#
			- C#中所有值类型继承自System.ValueType，故有一套通用的的成员属性、方法
				- int.MaxValue
				- int.MinValue
				- double.MaxValue
	- 限值带来的影响
		- 如果运算生成的值超过这些限值，则会出现下溢 或溢出 的情况，不同的语言对于溢出的处理可能不同
			- C：
			- C#：
			- 

### 非数值类型
#### 字符类型(char)
- 用来表示所有的非数字字符
- 字符串类型和单字符类型在内存存储上的不同？？
	- 可以认为 字符串 == 一串连续的单字符吗(即，可以认为 字符串 == 字符数组 吗)？
		- C++中：
			- 1. C风格字符串is：
				- char* 型的
			- 2. string字符串不可以看作：
				- 因为string是一个类(class), char*字符串内容只是string类的一个成员，除此之外，string类还包含很多原始char*数组不含有的成员方法
		- C#中： C#中含有几种字符相关的类型？？单字符 、字符数组、字符串，(C#中数组继承自Array类)
			- char
			- char数组
				- 但是更推荐使用string，虽然数组继承自Array也是一个对象
			- string

#### 布尔类型
- 用来做逻辑相关的


## 实体(变量/对象，表达式，函数) + op -> 表达式 + 流程结构 -> 语句 ，块(pure块(无名块)，函数块(有名块，可通过函数名(语句代码块存储的地址)来调用)) -> 类、

### 实体
- 每一个实体都有类型

### op运算符 && 优先级
- 如果每一行都只用一个op是不用制定op间的优先级的
- op的优先级 is 为了处理一个表达式(同一行)同时使用多个op运算符时，
	- 不确定优先级的就是用 ```( )``` 来进行强行保障顺序


## 程序的完整工作流程
- 从源文件编辑开始 -> ... -> 结果输出，中间的每一步的详细经过
	- 不同语言的这个过程一般是不同的

### C#的

### C/C++的

### JAVA的





# 类型
### 1. 编译型or解释型or混合型
#### why 要弄成混合型？
1. 每种编译形式都有其存在的原因
2. why java C# 要设置成混合型？优点是什么？跨平台、比解释的快、比编译的跨平台？
#### 混合型
1. JAVA的
### 2. 动态类型语言or静态类型语言
#### 动态类型语言：
- 动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。
- Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。
#### 静态类型语言：
- 静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型。
- C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。
### 3. 强类型定义语言or弱类型定义语言
#### 强类型定义语言
- 强制数据类型定义的语言。也就是说，__一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了__。
- 强类型定义语言是__类型安全__的语言。
- 举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。
#### 弱类型定义语言
- 数据类型可以被忽略的语言。它与强类型定义语言相反, __一个变量可以赋不同数据类型的值__。
- 强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。
- 另外，“这门语言是不是__动态语言__”与“这门语言__是否类型安全__”之间是__完全没有联系__的！




# 泛型concept
- 是什么
- why need 泛型

- 都有什么可以被泛型？？
	- 泛型类
	- 泛型接口

## 泛型类
## 泛型接口
## 泛型值类型


## 泛型约束
- 是什么
- why need 泛型约束




# 流程
## 顺序
## 分支
## 循环
## 遍历
## 事件-委托机制(发布者-订阅者模型)
## 协程
### why need 协程？
1. to解决进程-线程的痛点
	- 进行-线程的痛点：
		- 数据安全方面：
		- 性能方面
2. 经典例子：
	- 生产者-消费者模型的线程版实现

### 协程is什么？
1. 协程，英文Coroutines，是一种比线程更加轻量级的存在
	- 1. 正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。
	- 2. 之所以说轻，其中一方面的原因是协程所持有的__栈比线程要小很多__，java当中会为每个线程分配1M左右的栈空间，而协程可能只有几十或者几百K。
		- 这和线程||协程的栈中存储的主要内容不同有关

<img src="C:\Users\king-kong\Desktop\BlogPlan\4+1\Gitmind\Picture\进程-线程-协程.jpeg" alt="进程-线程-协程的关系" style="zoom:70%;" />

2. 协程的特点在于是一个线程执行
	- 协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。
		- 不会像__线程切换__那样消耗资源
			- 子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。

3. Donald Knuth：“子程序就是协程的一种特例。”
	- 协程可以在调用子程序的时候中断立马返回
	- 普通子程序调用一旦开始必须同步执行完才返回

### how to use 协程

### 支持协程的语言
1. Lua语言
- Lua从5.0版本开始使用协程，通过扩展库coroutine来实现。
2. Python语言
- 正如刚才所写的代码示例，python可以通过 yield/send 的方式实现协程。在python 3.5以后，async/await 成为了更好的替代方案。
3. Go语言
- Go语言对协程的实现非常强大而简洁，可以轻松创建成百上千个协程并发执行。
4. Java语言
- 如上文所说，Java语言并没有对协程的原生支持，但是某些开源框架模拟出了协程的功能，有兴趣的小伙伴可以看一看Kilim框架的源码：
	- https://github.com/kilim/kilim



## 异步回调
## 并行--并发
- 并行和并发的一种理解是：核心数够不够
	- 足够
		- 真正是一个核心跑一个，怔真正的并行
	- 不够
		- 宏观上并行，但存在多个在一个核心上分时来轮询着跑的情况
### 多进程
- 进程间不共享数据，进程间的通信是一个问题
	- 本机进程间通信
		- 信号量
		- 消息队列
		- 共享内存
	- 远程进程间通信
		- tcp/ip
		- http
- 通信时的数据安全问题：
	- 上锁
### 多线程
- 因为各个线程与主线程间共享数据-> 不需要线程间通信(通信的目的is传递数据)
	- 多个线程间能共享数据，而进程间不行的原因is：
		- 多个线程和主线程在一个cpu上跑？
			- 每个cpu上是存储器共享的？
		- 而不同的进程可能在不同的cpu上跑
- 数据的安全问题
	- 上锁
#### 线程池
https://en.wikipedia.org/wiki/Thread_pool
##### why need 线程池
如果为每个指令创建一个线程，最终可能会有许多线程，每个线程的生命周期都很短。这种情况下可能会挑战 CPU 和操作系统处理能力的极限。

设置一个线程池可以缓解线程生命周期的问题。但是，即使使用线程池，也可能会同时激活大量线程。线程数多于 CPU 核心数会导致线程相互竞争 CPU 资源，进而造成频繁的上下文切换。


## SIMD
- 主要是充分利用起来gpu的能力
	- 集显
	- 独显

### C# unity3d版的gpu加速

### 裸的C++来操作gpu？？

## 异步编程
### await - async机制
- ecmascript中使用await-async来实现异步编程
- C#中也使用async-await实现异步编程
- 

# 存储
## 静态联编||动态联编
## 静态存储区||动态存储去||局部存储区
- 单元素类型怎么存？
- 多元素类型怎么存？
	- class中的数据成员是怎么存的？存在哪？连续存or非连续存？
	- struct
		- struct中的数组成员是怎么存的？
	- enum中？
	- union中？
		- union机制是弱类型的基础？
	- 数组类型？
		- 静态(编译期)数组？
			- C++: Array <>
		- 动态(运行期间分配内存)数组？
			- C++: Vector <>
## 存储位置--作用域||链接性

## 泛型的实现机制

## 多态的实现机制

## 垃圾处理机制
### GC
#### 标记清楚
#### 引用计数(js，java,c#均有涉及)
- __循环引用__的严重bug使引用计数不常用
### RAII

# OO
## 一个类的一切
### 属性区
### 方法区
### OP区

## 类间的关系
### is-a
#### 公有继承
### has-a
#### 复合(包含)
#### 私有继承

## how to 写一个好的类
- 从大厂开源的编程风格中学习(哪些特性可以用，哪些特性不可以用)
### C++的google开源风格
### JAVA的阿里巴巴开源风格
### C#的microsoft开源风格
### 从多个大厂的风格中总结出 -> 一些优秀的的concept


# 基于对象&&面向对象
## js是基于对象的



# 顶层抽象
- 这是哪本书里讲的？属于哪个领域里的知识？
[]()
## OO面向对象编程（Object-Oriented Programming）

__抽象__

- 生活中充满复杂&&错综 -> 处理复杂性的方法之一 is __简化&&抽象__
- 生活中的哪些可以抽象？抽象成什么？(class , interface , struct , )
- 哪些不可以抽象？why不可以?存在本质的东西-应该都能在编程中找到一一对应的项
- 
__继承__和__组合__
__封装__he__隐藏__

- 类的all公有部分构成 __公共接口__
- 类的all私有部分构成 __数据隐藏__
- 通常，数据成员放在私有部分，方法成员放在公有部分

__多态__

- 重载？
	- 方法重载
	- op重载
- 覆盖？




## CO面向组件编程（Component-Oriented Programming）
## SO面向服务编程（Service-Oriented Programming）
## AO面向方面编程（Aspect-Oriented Programming）



## ECS（Entity-component-system）
- 游戏开发中使用的一种模型
	- unity 中的 ECS：
		- 针对 Gameobject/MonoBehavior模型的一系列缺点 -> ECS模型



# else(杂项)
## 对象池(Object pool) 与 线程池(Thread pool)有有一丝的关系吗
- pool(池)的这种设计逻辑，本质上的好处是什么


## 反射||属性
- 是什么
- why need 反射


## 正则表达式

### 正多则表达式的妙用

1. 正则表达式 && 属性类 结合 -> 用作名字合理性判断等等
	- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\正则表达式1.PNG" style="zoom:60%;" />
	- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\正则表达式2.PNG" style="zoom:60%;" />
