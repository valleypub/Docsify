[toc]

# 疑问
- 普通变量的地址在他的生命周期内是固定不变的吗？

- struct内部可以有string成员，可以有class成员吗？？？
	- 可以有union成员，even可以有匿名union
	- 可以有static类型的成员吗？，可以有static类型成员的自def类型（enum union class struct）有哪些？？？？
	- 可以有op重载区吗？？
	- 是想书中说的那样，和class只有默认限制符这一种区别吗？？

- 普通类型的变量值类型使用时，可以用&找寻address,   那class  or  struct or enum or string等复合类型可以使用&找寻address吗？？？

- & （取址符）的内部机制是什么？ 值类型（名字方式使用）的内部机制是什么？？？
- *（解引用） 的内部机制是什么？
- C++ 通过上下文来确定 * 是 解引用 or 乘法
- 上下文推断机制？？ 
- 编译阶段决策 && 运行阶段决策
	- 如传统的C++声明数组 is 编译阶段决策，故数组长度必须在编译阶段就确定下来
- 静态联编 && 动态联编
	- 编译时给数组分配内存  is 静态联编 static binding
	- 运行时确定数组的长度 is 动态联编 dynamic binding
	- new 都是在运行期间执行的，都是动态联编
		- int * apple = new int[30]; is 在运行期间执行的
		- 采用数组声明方式 int apple[30] = { }; is 在编译期间执行的 ， is 静态联编
	- 
- 只能对new分配的内存使用delete释放，非new开辟的内存不能使用delete（ru: 普通声明的变量 int name = 55;）
	- 对空指针使用delete是安全的，但没有意义
- 不要delete已经释放的内存块，这样做的结果是不确定的。(什么都有可能发生) why？？？？为什么这么神奇？？究竟发生了什么
- new时使用了 [ ]则delete时也要使用 [ ],new时未使用[ ],delete时也不能使用
```
//
int * ptr = new int [10];
// []告诉delete释放整个数组
delete [] ptr;
//new时开辟了一个数组，如果不加 []则释放时只会释放指针指向的那一个元素
delete ptr;

//
int * ptr = new int;
delete ptr;
```

- 数组名是一个 const类型的指针不可修改，但是可以通过数组名值赋给一个指针 + 修改指针 -> 来修改指向
```
int * applle = new int[30];
//applle是一个const型，为常量，运行期间不可变
apple = 0xasdfgrhjk;//错误
apple++;//错误
//但是可以通过,过度指针来进行改变指向
int * ptr = applle;
ptr += i; // 标识指针移动 i个指针类型大小的长度
int temp = *ptr;

```

- 使用auto时，右值为0 （而不是0.0）时，会推导出错。二义性？？不知道推到成 false（bool）,or 整形 or char型 ?? 说明 这些在内存真正存储的是 **一样的01序列** && **一样长**???
- C++的强制类型转换
	- C版的： (typename) value
	- C++版的
- C++数组的两种替代方式
	- array模板类 is 在静态存储区，静态联编方式(编译期间确定长度)
	- vector类使用动态联编，动态存储去


- 为什么需要函数原型(函数的提前声明)???
	- 和变量的声明一样为了告诉编译器一些接口方面的信息， -> 
- 避免使用函数原型的唯一方法是在函数使用之前定义它，如将函数的定义放在main()上方，利用了顺序编译的特点？？？why unity中不需要函数提前声明???


- C++函数 默认 采用按值传递参数 == 拷贝一份给形参


- 宏替换 && inline内联函数 && 函数调用的取舍
	- 特别短小的函数写为宏替换方式
	- 重写开销 && 调用开销 的比较 来决定使用inline or 普通的函数调用
	- 就算写了inline 有的编译器也不支持inline函数。


- 引用和指针的区别？？

```
//下面两种引用方式的区别？？？？？？？？？？
int b = 0;
int& a = b;
与
int& a = 0;
int b = a;

```

- 引用型返回类型&&常规性返回类型
	- 常规性返回类型 ：
		- is 右值，不可被取地址
		- 会复制返回值到一个临时对象，再将临时对象复制到外部变量。效率较低
	- 引用型返回类型
		- 要防止返回函数终止时不再存在的内存单元的引用
			- 1. 通过返回一个作为输入参数传递给函数的引用来解决
			- 2. 

- 函数返回引用类型怎么使用？？？

- 函数抽象声明-定义&&函数重载&&函数覆盖

- 模板函数也可以进行重载

- 模板函数的两个问题
	- 1. 模板函数内部op(如 相加)后是什么类型
	- 2. decltype解决了1.
	- 3. 模板函数返回什么类型？
	- 4. 返回类型后移机制+decltype机制解决了3.


- 函数原型（函数声明）可以有多个，函数的定义（具体实现）只能有一个，重复定义会出错，why重复定义会出错，重复声明不会出错？
- 内联函数inline的使用
	- 函数声明时加inline：inline returntype  funname();
	- 函数定义时加inline：inline returntype funname(){  ... };
- 普通函数重复定义会报错，inline内联函数重复定义不会报错？？？


- __c++的类型究竟分不分引用类型、值类型？__
- why string类型 存储的是指向字符串对象的地址？int 、 double直接是值，class类型也是地址？
	- 那 className obj; 和 className * obj；有何区别呢？？存储的不都是地址吗？？
	- string str; 和 string * str;也没什么区别吧？为什么不直接搞一个引用类型？



# C++ Primer Plus 第六版 -- 总结

## 关键字

### 类型别名
- 1. typedef
```
typedef uchar unsigned char;

```

- 2. using
```
	using SI = int;
```

### 类型推导
- 3. auto
	- 使用auto必须声明的同时显式初始化
		- 因为auto是推导出右边初始化的值的类型来作为左边变量的类型
		- 如果右边初始化的值是一个引用类型的对象or变量，auto只能推导出右边对象的类型，引用会被破坏，此时应使用auto& xxx = yyy;

	- auto推导出的类型和初始值的类型并不完全一样
		- auto一般会忽略掉顶层const,底层const会保留下来
	- auto推导仅推导变量的类型，但是会破坏”引用“ -> auto& 才能保持引用

```
	int t = 30;
	int& m = t;
	
	//值类型推导
	auto t1 = t;
	
	//引用类型推导，引用会被破坏掉
	auto m1 = m; //这种能用吗？or会被破坏掉 -> 等价于什么形式？？会不会退化为int m1 = t??因为auto只能推导出引用的类型会破坏引用？？
	
	//
	auto& m2 = m
	
```


- 4. decltype()
	- decltype( (variable) ) 双层括号的结果永远是引用:不管变量本身是值类型 or 引用类型 
	- decltype(variable)  与variable保持一致
```
	//1. 从函数的返回值推到类型
	decltype(foo()) a;
	//2. 从表达式推到，可以从constexpr常量表达式
	decltype(r+0) s;
	//3. 从普通右值推导

```

### c_v限定符
__const__

- const与引用
- const与指针
```
	int a = 666;
	const int * const pointer = &a;
```

- 顶层const && 底层const
	- 顶层const表示任意的对象is常量。对任意数据类型适用：算术类型、类、指针；
	- 底层const表示指针所指的对象is常量
		- 用于声明引用的都是底层const
	- 底层-顶层const对于对象拷贝有影响
		- 顶层const对拷贝没啥限制
		- 底层const的限制
			- 非常量可以拷贝给同类型的常量类型
			- 常量类型却不可以给同类型的非常量类型
```
	//const修饰的变量pi本身is常量，const是顶层const
	const int pi = 3;
	
	//const修饰的变量p指针本身不是常量，p的指向是常量，所以此const为底层const
	const int* p = &pi;
	
	// cosnt修饰的变量ci值不能改变(即指向不能改变) -> 是一个顶层const
	int* const ci = p;
	
	// 右边的const是顶层const,左边的const是底层const
	const int* const di = p;
	
	// 用于声明引用的都是底层const
	const int& ei = pi;
```

__constexpr__

- constexpr 和 常量表达式

__volitate__




## 运算符

### 三目运算符( ? : )
- 三目运算符可以嵌套
- 三目唯一要考虑的是，后两个表达式的返回类型要一致。
	- 且有返回时只能做右值->左边必须有同类型的变量
	- 返回值类型是void时可以左边无变量
```
int x = 0;
x = (a>b)? (a>c)?a:c :
```

### sizeof()





## 第一章
- 从4.3版起，g++要求您编译源代码文件时，使用标记 -std=c++0x: ``` g++ -std=c++0x use_auto.cpp ```

## 第二章 进入C++
- 1. C++ 对大小写敏感
	- cout -> COUT
- 2. 文件扩展名：cpp,cxx,不同的平台支持的不同
- 3. 支持“裸的”变量&&函数
	- 裸的变量 && 静态变量(static)的区别
	- 裸的方法 && static方法的区别
- 4. C++的入口函数
	- 返回值方面：**标准推荐使用int main(){}**  rather than  **void main(){}**
	- 因为大小写敏感->函数名只能是main
	- DLL模块不是独立的程序，不需要main(){}入口函数

```
int main(){}     <==>  int main(void){}   != int main(int argc,char ** argv){}
```

- 5. C++是静态类型语言，->  每个实体（变量(对象)、表达式、函数）在使用前必须声明
	- 类型声明  究竟都做了什么? 为什么要类型声明???

## 第三、四章 C++中的类型

![C++的类型总览图]()

### C++命名方案
- 大小写敏感
- 字母、下划线、数字的组合
- 第一个字符不能是数字
- (两个下划线、一个下划线)or大写字母打头的名称保留给实现(编译器及其使用的资源)使用
- C++对名称的长度没有限制，但平台可能有限制
	- ANSI C（C99）标准：名称的前63个字符有意义。
		- 两个名称认为是一样的只要前63个字符相同，而不管64以后的字符是否相同


### C++类型

#### 内置类型

#### 复合类型（基于其它类型的类型）
##### 引用
左值引用

右值引用

##### 指针

#### 类型限制符

#### 类型的使用方式
- C++中的类型的区分很混乱，完全不如C#(只有 值类型、引用类型)的简洁明了
- C++的各种类型的使用方式是怎样的，变量中存储的究竟是什么？realData or address
	- 默认方式
		- typeName valueName;
	- 引用方式使用
		- typeNmae& valueName;
	- 指针方式使用
		- typeNmae* valueName

![使用方式区别]()

- 引用和指针的区别？？
	- 引用的特点：
		- 引用i"一生爱一人的"
		- 引用必须在创建时就初始化(即“绑定”)
			- 但是vs中的C++可以只声明不初始化，那这不是通过const指针实现的吗？
	- 指针的特点：
		- 指针的指向可以随意变化，除非是用了const限制指针
- 引用和指针方式的底层实现原理是什么？
	- 指针和引用都是在汇编层进行解析的？
	- 引用 == 一个常指针( int * const pointer = nullptr)
		- 通过常指针的定向性 来实现 引用的"一生爱一人"机制


## D九章

### 存储区

- 每种存储区从这3点：存储持续性-作用域-链接性，进行考虑
- 避免不加限制的使用全局访问权，会导致程序不可靠。
	- 1. 尽量使用局部变量，除非有特别的考虑
	- 2. 外部存储(多文件+外部链接)极其适合表示const修饰的常量数据
- 范围低的有效在作用域内覆盖更高范围的有效？？
	- 嵌套块中，每下层的覆盖上层的
	- 自动的类型 覆盖 全局类型
- 共享数据de方式
	- 不使用const的
		- 1. 使用外部变量在多文件之间共享数据
		- 2. 使用链接性为内部的static变量在同一文件的不同函数间共享数据（同一副本）
	- 使用const的
		- 因为const == const static的隐式含static的这个特性 -> 使作用域都变得和static一样 

#### 自动存储区（局部生命周期）-- 栈

- 局部-没有链接性

- auto 原先是指示自动的 -> c++11后用于局部变量的自动类型推导
	- 必须是局部变量（自动变量）
	- 必须存在右值(声明同时初始化)
- register原先是指示使用cpu寄存器存储变量 -> c++11后 只用于指示自动变量（局部变量）（和原先的auto一摸一样）
	- 之所以没有废除一些关键字ru:register是因为防止之前版本的使用了此关键字的项目代码变得违法

- 编译器一般提供改变栈长度的选项
- 

#### 静态存储区

- 三种链接性，两种局部性
- 1. **在all函数外声明**（头文件中也属于all函数外）&&**不使用static**   ---- 全局-外部链接性（外部文件也可使用）
	- 1. 在每个要用到外部定义的变量的文件中都必须声明它
	- 2. 由于C++的ODR规则-> 变量只能有一次定义
	- 3. 为满足1-2，c++提供两种变量声明：定义声明（简称定义）、引用声明（简称声明）
		- 引用声明must使用关键字extern，仅表明引用已知的变量，不进行变量的初始化（分配空间）
		- 除了extern的纯声明外，一切声明皆为定义声明，会分配存储空间（如果不显式初始化，也隐式初始化）
	- 4. 要在多个文件中use外部变量，只需在一个文件中定义声明，在所有要使用它的文件中进行引用声明(extern)即可。
		- 这种like类中的同一副本？多个文件会同时修改同一个变量的状态？？

- 2. **在all函数外声明**（头文件中也属于all函数外）&&**使用static声明** --- 全局-内部链接性（单文件可使用）
	- 由于ODR不仅在同一文件不能定义声明（分配内存的声明）两个相同的变量，即使在不同文件中也不行（如：两个头文件中）
		- 1. 使用extern来确保只有一个本体，别的均为引用
		- 2. 使用全局-内部链接 覆盖掉 全局-外部链接
```
//file1
int error = 0;

//file2
int error = 0;//错误，重复定义，file1中定义过了
static int error = 0;//正确，低范围覆盖掉了高范围的，

```

- 3. **在函数内声明**&&**使用static声明** ------ 局部-无连接性（只不过在函数未被调用的时候，整个程序运行周期内都一直存在，只是只有此函数可以使用）
	- 局部static只在第一次函数调用时初始化一次，后续调用不再初始化。
		- static静态联编is编译期间进行分配的->方法调用也是在编译期间就执行了的？？
	- 既然一直存在，能不能通过指针来在函数调用期外对局部static进行访问？？？
- 4. 在函数内声明&&不使用static ---------自动存储去-局部-无连接性（只有函数调用时，在开辟的栈上-短暂的存在）

- 5. **在class内声明** && **使用static** 是属于 2. or 3. ？？？？？

#### 动态存储区(heap上的)
__作用域-链接性-存储连续性 is 怎样的？？__

__存储来连续性__

__作用域__(生命周期)

- 只要不delete, 整个程序运行期间存在？？？ 





#### 存储相关关键字
- auto
- register
- static
- extern
- mutable

#### c-v限定符
##### const
```
const int pi = 3.14; == const static int pi = 3.14;

```

- 1. const在链接性上：默认为内部链接( <==> const == const static), const改变了普通全局变量的外部链接性
	- 1. const && 头文件的组合使用(all函数外使用const) + 每个源文件均include头文件来获取一个孤立副本
		- const == const static -> 作用域is**全局单文件有效的**
		- **extern const** float pi = 3.14;
			- **通过const前加上extern来将const修饰的变量变为多文件共享的**(const的隐式static局部性的穿透)，别的文件只需要引用声明(extern flaot pi;)即可
		- 比不use const声明的在分配存储处(定义声明)要多写个extern
			- 普通非const的普通全局变量（all函数外的）因为不自动使用static -> 自动是全局链接的(多文件共享的)（不需要在定义声明处加extern）,只需要在引用声明处+extern标识

	- 2. const && （函数or代码块内使用const ）
		- const == const static -> 作用域is**局部(函数or代码块)有效的**，但是全局存在(编译期就开辟？)
			- 好处是多个函数内可以使用const声明多个**全局存在-局部有效的**同名变量 
				- 这些是怎么避免名字冲突的？？不相当于全局存在多个同名的变量了吗 

- 2. const在可变性上：
	- const修饰的变量值不可变(==常变量) -> 如果一开始-> const修饰的变量必须显式初始化？不是存在默认初始化吗？大不了使用默认初始的0 or null难道不可以？
		- const机制底层是通过什么方式实现的？？
	- const修饰的变量必须显式初始化
	- 

- 3. 强行改变局部const变量的方式
	- 1. 使用指针修改：
		- 全局const变量存储在全局空间，且只有可读属性，无法修改其值？
		- 局部const变量可以进行改变？
		- 编译器对变量进行的常量折叠使修改失败？
	- 2. 使用volatile关闭__常量折叠__
		- 由于编译器对const修饰的变量进行了优化，使得对于const变量值的读取实际没有进入内存。而在此基础上加上volatile关键字，即告诉编译器该变量属于易变的，不要对此句进行优化，每次计算时要去内存中读取该变量的值,进而避免出现常量折叠的问题
			- 常量折叠：
				- c++编译器层的一种优化
				- const变量（即常量）值放在__编译器的符号表__中，计算时编译器直接从表中取值，省去了访问内存的时间，这是编译器进行的优化
				- 只对局部变量进行折叠？？
	- 3. 使用强制类型转换const_cast<>();
	- 4. mutable进行const穿透

- 4. 推荐的const用法
	- 值不想被改变的变量才声明为const
		- const的提出就是为了提供使一些变量不可被改变(通过一旦改变会报错-提醒的方式)来模拟现实中存在的常量概念
	- 使用const时能显式初始化就显式初始化
		- 因为常量一般是能提前知道值的，刻意显式初始化能减少混乱和使代码变得简洁
		- 对于无法提前知道值的常量 use: __默认初始化 + 强行改变const变量__来实现动态声明常量变量的效果
	- 能不强行改变const变量就不改变
		- 3中的改变const变量is万不得已之策，因为const的本意就是不可被改变

- 5. const的初始化||内存分配
	- const修饰的变量默认初始化不分配内存？除非使用 extern or & ？？？

##### constexpr
##### voliate
- 表示
##### mutable


### 各种变量的值的存储的位置||确定的时间
#### 存储的位置
- 静态存储区:
	- 全局变量
		- 任意修饰符修饰的全局变量均is静态存储区？？
	- static修饰的变量
		- static修饰的变量(不管是全局or局部)都存储在静态存储区 -> is编译期间确定的(初始化)，整个运行期间均存在。但，!= 作用域is全局的，
		- static修饰的变量的作用域
			- 一般情况下和不加static一样
			- 但，对于全局的变量，static会使外部链接性 -> 内部链接性(相当于变小了)
- 动态存储去(heap)
- 自由存储区(stack)
#### 变量分配内存确定的时间
- 确定的时间只是编译器给变量首次分配内存位置的时间(一般可看作初始化)，这个确定时间is第一次给，后续是变量is可以改变的(即，一旦给变量分配了内存空间，便可以给变量赋值、取值了(底层is通过对变量对应的那个空间进行操作))
	- 很好理解，第一次编译器给你(变量)分了一个筐(内存空间)，你就可以用这个筐去随意装东西了


![](C:\Users\king-kong\Desktop\要做的事情\picture\存储区.png)



### 代码复用的方式

#### 头文件-源文件分离（将common复用率高的提取成一个头文件，通过包含来使用）
- 头文件中可以放置的项
	- 1. 函数原型
	- 2. 结构声明
		- 因为创建struct类型的时候并不会创建实际的变量，只是在源代码中用此struct类型创建变量的时候，告诉编译器how to 创建该结构变量
	- 3. 类声明
		- 如果没有static成员就和2.中一样，如果有static成员（因为是全局的）一旦class创建完就能开始use了，那不相当于实际创建了，此时还应该放置于头文件中吗？？？
	- 4. 模板声明
		- 不是将被编译的代码，而是同2.一样指示编译器how生成代码
	- 5. 内联函数
	- 6. 使用#define或const定义的符号常量

#### 

### 链接性(访问控制权)

#### 变量&&链接性


#### 函数&&链接性
- 和变量一样，函数也有链接性
- 和C一样，C++不允许在一个函数中定义另一个函数 -> 只能在all函数外部 == 都是静态存储区(全局存在的--但是作用域可变，通过static来改变)
	- 默认情况下，函数的链接性为外部的 -> 可在不同文件间共享 (一个主的定义声明，别的是引用声明extern)
	- 可以使用static -> 函数的链接性为内部的 -> 全局-单文件
		- 必须在函数原型(声明)和定义均使用static关键字
		- 使用static的好处：
			- 1. 收敛一下作用域 -> 使其他的文件可以定义同名函数
			- 2. 可以使用static来覆盖外部文件定义的全局的同名函数

- ORD同样适用于函数
	
	- 所有文件中只能有一个函数定义，但是使用此函数的每个文件需要包含函数原型(函数声明)
- ORD不适用于inline内联函数
	- 内联函数的定义可以有多个
	- 必须在每个使用inline的文件中给出inline函数的定义(与ord背道而驰)，why这样设计？？
- but,c++规定同一inline函数的all函数的定义must相同
	
- C++去哪里查找函数定义
	- 1. 首先compile查找函数原型 -> 确定是默认的(外部链接--所有文件) or static(内部链接--单个文件)
	- 2. static静态的
		- 只在该文件中查找函数定义
			- static函数如果声明在哪个文件(ru:头文件) -> 函数定义也要写在相应的文件？？？NO。由于ODR存在 -> 只能有inline一种函数这样写，别的都不可以。static方法定义不可以写在相应头文件中，要在include头文件的文件中写函数定义
	- 3. 默认的的
		- 在all文件中查找(包括库文件)
			- 先在所有的自定义程序文件中查找
				- 找到>=2个 ， error
			- 再在all库中搜索


## D十-十五章(how to 写出好的类)

__1. 什么情况下才应该use类__

__2. 怎样设计类__






## 附录1--使用ISO-C++

### 声明常量用 const 替换 #define

#### #define 的缺点
1. 作用域上
- 只能放到all函数外最前方 -> 全局-外部链接？？
- 全局->严重的冲突问题
2. 常量的类型上
- 默认只能是char、int、double
- 除此之外的类型要添加后缀来指明
	- 3.14F , 100L
3. 不能用于声明复合类型常量
- 如：不能声明常量数组

4. 采用的编译期字符替换的方式
- 字符替换有时会带来奇怪的问题
	- 不只全局变量，局部变量也会被宏给替换
```
	#define n 5
	int main(){
	
	    int foo(){
	    int n;
	    //会在编译期间替换为 int 5; -> 编译错误
	
	    }	
	}
```
5. const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误。


#### const声明常量的优点
1. const == const static（除了类内的const此不适用）
- const也是静态存储区上分配(编译期间指定？)
- const == const static 只适用于 [非类内的&&全局的(all函数外的)const才成立??] [局部的cosnt这个等式成立吗]

2. 可以显示指定常量类型，而不需使用后缀的方式
3. 可以方便的声明 复合类型常量 ，如：常量数组
- const string name[] = {"a","b","c"};
- const int number[] = {1,2,3};

4. 作用域可以是全局的、局部的（名称空间、块）-> 不易引起冲突
5. const == const static 即是内部链接的(单文件的)
- 看起来是每个使用const常量的都要在文件内单独声明一份，增加了工作量，但是由于降低了冲突性，其实是减低了工作量
	- 实在想多文件共享也有2种办法：
		- 1. 将const常量组 放置在 头文件中，被多个文件包含
		- 2. 使用 __extern__ const double pi =3.14; 配合 extern double pi;来使用

6. 可以节省空间，避免不必要的内存分配(空间上)||提高速度(时间上)
- 空间上：
	- const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象宏一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而宏定义的常量在内存中有若干个拷贝。
- 时间上：
	- 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期的常量，没有了存储与读内存的操作，使得它的效率也很高。

### 定义小型函数 inline 替换 #define
#### #define
1. 是文本替换 而不是 真正的传递参数
- 可能会带来意外的错误
```

```

2. 无法处理z++这种情况

3. 无类型的->对于任意类型都成立(is优点)
- 可以利用这个优点来 结合 ## 定义 动态变量名

#### inline
1. 采用的是真正的参数传递
2. 可以用于常规函数 he 类方法


### 使用namespace
1. 尽量避免一股脑地 using namespace std;
- 这与设计的初衷背道而驰

2. 可以使用 离散命名空间-组合的方式 -> 使特定的名称可用
```
namespace io{

using std::cin;
using std::cout;
using std::endl;

}

using namespace io;
```

### 使用智能指针
1. 防止引发异常而不执行delete提前结束 -> 内存泄漏
- 每个new创建的都必须使用delete, 无论是对象 or 变量 or
2. C++新增的 unique_ptr ， shared_ptr


### 尽量使用string表示字符串
1. char[] ( C风格 ) 由于不是一个真正的类型 -> 降低开发效率
- 只能使用全局方法
- 必须是可考虑 "\0"结束标志问题

### 使用STL(这是一组设计的很精美、高效的东西)
1. 使用Array (定长), vector(不定长) 取代原本的C风格数组 []


### C++空指针
1. c++98中，字面值有两种含义：可以表示数字值0、也可以表示空指针 -> 会导致编译器难以区分。
2. 也有人使用宏NULL、（void*) 0 标识空指针
3. 但C++11提供了更好的解决方案：使用关键字nullptr -> 空指针

- 但之前的表示空指针的方式仍有效，不然会有大量的先前的代码非法

### 使用枚举类(enum class)代替旧的枚举类型(enum)
1. 旧的枚举类型的缺点：
- 1. 会将枚举成员引入周围的命名空间，导致命名冲突
```
const std::string bear = "bear";

//error: "bear" redeclared as different kind of symbol
enum Animal {dog, deer, bear};
```

- 2. 会隐式转换为int

2. 新的enum class
- 1. 枚举类型成员对枚举来说是局部的，不会带来名字冲突
- 2. 枚举类成员值不会隐式的转换为其他类型(另一个枚举 or int类型)


```
```



