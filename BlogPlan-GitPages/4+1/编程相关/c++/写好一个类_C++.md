[toc]



# 一个类的一切

## 成员区
### 存储数据相关的

#### 字段


### 处理数据相关的
#### op
- op本质上是方法的一种特殊表现形式

- 一般内置的op都是针对一些内置类型的(ru : + - * -> 数字类型 ，+ “ ” -> string类型)，而class这种自def类型一般是没有op可以使用，除非在类内对op重载。struct可以含有op重载吗？？

##### op重载的限制

- 1. 使用运算符不能违反运算符原本的句法规则
	- 因为原本成员方法is够用的，之所以使用op重载 -> 只是want以原先的op句法规则的方式use成员方法
		- 如果句法规则都该就没有什么意义了

- 2. 不能创建新的OP运算符，只能对__现有的OP运算符__重载
	- ru: 不能定义 operator** ()
	- 

- 3. 现有的OP运算符
	- 不能重载的OP
		- __sizeof()__
		- __.__
		- __. *__
		- __::__
		- __?:__
		- __typeid__
		- __const_cast__
		- __dynamic_cast__
		- __reinterpret_cast__
		- __static_cast__
	- 能重载的OP
		- 只能通过成员函数重载的OP
			- __=__
			- __( )__
			- __[ ]__
			- __->__
		- 成员、非成员函数方式都能重载的OP
			- 

##### 像写成员方法一样写op重载
###### 创建op重载
- 定义的时候：只要将 __成员方法名 -> operatorOP__ 别的输入参数列表、返回类型、限制符都不用改
	- 也就是说，op重载能实现的 使用 新命名一个成员方法 都能实现
		- 将成员方法名 换成 op 只是符合多年C的使用习惯，功能是一样的
```

```
###### use重载的op运算符
- 调用的时候： 有2种调用方式
	- 1. 类成员方法式使用：C = A.operator+(B)，
	- 2. 类C式使用 ： C = A + B;
	- op重载符在使用时会被转换成函数调用？？
```
	Time A,B,C;
	C = A + B;
	// + 会被转换为
	C = A + B -> C = A.operator+(B);//像成员函数一样的用法
```

#### 方法
##### 构造方法(类的初始化与稳定)

- is什么
	- 
- why need it
- 3种类构造的方式
	- 类内初始化
	- 初始化列表
	- 构造函数

- 无法使用对象来显示调用构造函数(只能通过专门的对象构造表达式隐式调用) <- 因为在构造函数构造出对象前对象不存在
- 构造函数必须在类声明or定义的时候通过对象构建表达式使用
	- 显示调用
		- className objName;  objName = new className();
		- className objName = new className();
	- 隐式调用
		- className objNmae();

- C++11支持列表初始化
	- __1. 只要提供一个和某个构造函数的参数列表相匹配的内容__ + __2. 用括号{}括起来__
```
class Name{

private:
	Sring firstName;
	String secondName;

public:

	//构造函数
	Name(const string& firstName_, const string& secondName_ = " "){
		firstName = firstName_;
		secondName = secondName_;
	}
	//做好提供一个，默认无参的构造函数
	Name(){
		firstName = "none";
		secondName = "none";
	}
}

	//使用初始化列表进行初始化
	Name stu1 = {"Kang","kai"};
	//初始化列表也可以和默认参数配合使用
	Name stu2 = {"Xuan"}
```

- to安全 --> 设计类时通常应重载一个无参默认构造函数为每个数据成员隐式初始化
	- 因为一旦自def了构造函数(不管是什么形式的)->默认构造函数失效 ->只能自己显式的再写一个无参构造函数当作默认构造函数
- 同一个类的无参默认构造函数只能有一个，显式定义的无参默认构造会覆盖掉原本的默认构造函数
- (默认)构造函数对于一个类非常重要
	- 使一个类在声明-初始化后变得稳定，便于后续的使用
	- 如对于一些ADT的设计时，(默认)构造函数非常重要

- 因为只能有一个析构函数，而构造函数可以有多个 -> 所有构造函数都要与析构函数兼容。
	- 如果在一个构造函数中使用了new (or new [] ) -> 析构函数中必须使用delete(or delete [] ), 为了防止对未new的进行delete ->必须all构造函数保持同步，一个使用了new(or new [])别的构造函数也要给同样的成员变量使用new(new [] )，即使以空的方式使用

- __C++11允许类内初始化(在类声明中进行初始化)__ 是怎么实现的？？也是通过底层的构造函数？？C#也支持类内初始化
	- 类内初始化与成员初始化列表等价
	- 使用成员初始化列表的构造函数将覆盖相应的类内初始化
```
	class People{
		
	public:
		//	c++11才允许这样初始化，之前一般是通过构造函数来初始化的
		String name = " ";
		int years = 25;
	}
```

- 基类中__构造函数一旦使用new__ -> 需要进行一些连锁设置：
	- 1. 析构函数中使用相应的delete
	- 2. 别的构造函数中保持同步的方式使用new(可以使用空的nullptr)
		- 防止，对未new的内存区使用delete
	- 3. 显示定义复制构造函数&&重载赋值运算符(对于new相关的成员 or 引用类型的成员(string、class类型的) -> 改为深复制版的)
		- 因为如果使用默认的复制构造函数和默认赋值运算符的__浅复制__ 对于new，delete -> 会导致同一块内存多个指向 -> delete多次 or delete不同步( -> 乱码)的问题


##### 析构方法
- 与构造函数不同的是 -> 
	- 析构函数没有参数
	- 析构函数只能有一个
	- 析构函数不能被重载
- 析构函数的调用is编译器自动执行的不像构造函数要手动来
	- 通常不应在代码中显式调用析构函数 (除非类使用new来构造的对象) 。why??? 说明可显式调用
		- 如果对象是new创建的在__动态存储去__中 -> must在析构函数中使用delete来主动释放
		- 如果实例化的对象在__静态存储区__(static，or 在all函数外声明(== 全局的，全局的变量or对象存在静态存储区)) -> 程序结束时调用析构函数
		- 如果实例化的对象在__自动存储区__(局部的) -> 程序执行完其声明所在de代码块时调用析构
		- 对于没有名字的__临时对象( className(，，) )__ -> 在结束该对象的使用时自动调用析构函数
- 构造函数中使用new来分配内存时，必须在相应的析构函数内使用delete来释放内存(如果使用 new type[], 必须使用 delete[] )
- 因为只能有一个析构函数，而构造函数可以有多个 -> 所有构造函数都要与析构函数兼容。
	- 如果在一个构造函数中使用了new (or new [] ) -> 析构函数中必须使用delete(or delete [] ), 为了防止对未new的进行delete ->必须all构造函数保持同步，一个使用了new(or new [])别的构造函数也要给同样的成员变量使用new(new [] )，即使以空的方式使用




##### 普通方法
###### class的方法声明只能在类内部？(外部可以吗？) ， 方法定义在内部or外部都行
- 方法定义在类内部：默认is inline型的
	- 因为，inline只适用于很小的方法 ->__ 除非方法很小，否则不应该放在函数内部定义__
- 方法定义在类外部：默认is 回调型的，可通过显示 inline来定义成内联型
- 因为C++要求在每个使用内联函数的文件里都要有一份inline函数的定义 -> 类外部定义的inline成员方法要放到和class声明在同一个位置的文件里 (类内部定义的必然是符合的)

###### 如何设计成员方法的签名？
- 如何设计输入参数列表？ -> 无参 or 值类型参数 or 引用类型参数
- 如何设计返回参数？ -> 无返回值 or 返回引用 or 返回指针 or 返回值 or 通过输入参数来返回？？
- 能不用参数就不用参数 -> if必须用参数, 能使用默认参数就使用默认参数 -> 引用参数 -> 

###### 如何设计成员方法的返回类型？
- 不要返回指向局部变量的引用
	- 如果must返回引用 -> 使用 new声明成动态存储区上的
- 局部对象通过值类型返回(创建临时对象返回)
	- 注意是 __深拷贝__ or __浅拷贝__


##### 特殊成员方法
- C++会自动提供下面这些成员函数：
1. __默认构造函数__，如果没有定义构造函数
2. __默认析构函数__，如果没有定义
3. __复制构造函数__，如果没有定义
- Class_name(const Class_name &);
- 对于复制构造函数，需要知道两点：何时调用和有何功能。
	- 何时调用：
		- 1. 新建一个对象并将其初始化为同类现有对象时
		- 2. 无论哪种编译器，当按值传递和返回对象时，都将调用复制构造函数。
			- 按值传递意味着调用复制构造函数创建一个原始变量的副本。
			- 应尽量使用引用传递对象来节省空间和时间
		- 3. 编译器生成临时对象时，也将使用复制构造函数
			- 例如将3个 vector对象相加时，编译器可能生成临时的vector对象来保存中间结果。
	- 有和功能：
		- 默认的复制构造函数逐个复制非静态成员，复制的是成员的值(也称为浅复制)
			- 如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象(这不是深复制吗？？？不是，如：string类型成员存储的是一个地址，复制的时候只会将这个成员值复制过去，而不会将指向的字符串内容复制过去)
		- 静态成员属于整个类而不是各个对象，不变。
```
//这3种是复制构造
Class_name obj1(obj2);
Class_name obj1 = Class_name(obj2);
Class_name * obj1 = new Class_name(obj2);
//这种可能采用复制构造，也可能采用赋值运算符
Class_name obj1 = obj2;
```

- better__禁用默认复制构造函数__&&__定义一个显式复制构造函数__ <- because 默认复制构造函数可能会造成严重的问题 
	- 如：因为是浅复制，会将指向字符串的地址返回一份，但是如果原对象被析构了，会导致：
		- 新对象的字符串成员指向的位置会无效，返回一个奇怪的结果
		- 释放同一内存两次可能导致程序异常终止
	- 对于上述问题，直接定义一个显式的复制构造函数来进行字符串的深度copy -> 每个对象都有自己的字符串而不是指向别的对象的字符串
	- 其实对于__存在使用new创建的成员的类都应该显示重定义复制构造函数__+__使深度copy__ -> 来避免上述问题

4. __赋值运算符__，如果没有显式op重载
- ANSI C允许结构赋值(对结构对象使用=)，C++允许类对象赋值(对类实例对象使用=)，本质就是对=运算符默认重载了？
- Class_name & Class_name::operator=(const Class_name &);
- 对于赋值运算符，也需要知道两点：何时调用和有何功能。
	- 有和功能：
		- 默认的赋值运算符逐个复制非静态成员，复制的是成员的值(也称为浅复制)
			- 如果成员本身就是类对象，则将使用这个类的赋值运算符来复制成员对象
		- 静态成员属于整个类而不是各个对象，不变。
	- 何时调用：
		- 将已有的对象赋给另一个对象时，将使用重载的赋值运算符 != 在初始化的时候使用 = 
```
//使用assign operator
Class_name obj1;
obj1 = obj2;
//在同一行会使用复制构造函数
Class_name obj1 = obj2;
```

- 默认的赋值运算符会带来和赋复制构造相似的问题，解决办法如下：
	- 1. 从源头避免: 应避免将对象赋给自身 ，尽量使用对象的引用来代替
	- 2. 如果无法从源头避免 -> __使用显式重定义赋值运算符__ + __深度copy__来做

5. 地址运算符，如果没有定义

###### C++11还提供了另外两个特殊成员函数
1. 移动构造函数
2. 移动赋值运算符




## 成员级的特点

### const
- 是什么
- why need const

- 无const修饰的对象可以调用const && 非const成员(不会给对象or类的状态带来改变的方法or变量)，const修饰的对象只能调用const成员
	- 因为const修饰对象->对象状态不能变，但是调用非const成员无法保证不会改变对象的状态
- C++通过将const放在成员方法名后面 -> const型对象也可调用的不会改变对象状态的const成员方法
- to以防万一后续使用const修饰对象的问题 ->__ 一旦类方法不修改调用对象，就应将其声明为const__





### static
- 是什么
- why need it
	- 类中的static成员和裸的static(变量or方法)还不太一样：
		- 裸的static(变量or函数)中的static主要是用于限定 存储位置、确定时间 && 链接性(外部链接or内部链接)
		- 但是，类中的static主要用于模拟__类和all实例的对象共用同一分备份__的情况
			- 通过static是存储在静态存储区(一个不属于类和all对象的地方)来实现 -> all实例对象&&类共同维护同一个内存区域
				- 由于，static -> 静态存储区 -> 编译器期间分配内存 -> 类一旦声明好不与要实例化成对象，就可以开始使用static成员了
	- 同一类的不同对象和类间需要__实时共享一些成员__
		- 默认is多副本的
		- 使用static强行全局存在==共享唯一副本
	- static属性一旦class声明后就存在了,就可以开始使用(即使还没有进行实例化)，可以通过  className.成员Name 来随意使用


- static的特点
	- 修饰成员上：
		- 一般类静态数据成员(__static，const不同时用__)在类声明中声明，在include类声明文件的文件中初始化。（可以在类外声明吗？）
			- 静态类成员不能在类声明中初始化，必须在类声明外部初始化。(有没有位置限制？必须在类声明的外部上方？)
				- 静态类成员的__初始化位置__必须在方法文件中，而__不能在类声明所在的头文件中(class所在的那个头文件)__。
				- 静态类成员的外部初始化时，不需要带上static，但必须使用作用域运算符指出所属的类
			- 这一点和inline成员完全相反
				- 由于inline的特殊要求(每个使用inline的地方都要包含一份inline函数的定义，哪怕一样) -> inline函数定义放置在class声明所在的文件是最好的，每当class被include时，inline方法同时也被include
			- 除了inline之外的方法都是要遵循ODR(One Definition Rule), static限制的也不例外，因为class声明可能会被多个文件include(声明可以多次)，故普通定义不能放置在可能会被多次include的文件中(inline例外)
		- 如果静态成员是const修饰的 (整数类型 or 枚举类型) （即__const，static同时用__），可以在类声明中初始化。why？？？？
	- static成员使用上：
		- 外部类只能通过__className.成员Name__来使用
		- 声明static的类内部能通过__成员Name__来使用？？ 
	- 修饰类上：
	- 类继承上：
		- static成员无法被子类继承
			- 1. 因为static成员从存储本质上并不属于类 
				- 不属于你父亲的你也没资格继承
			- 2. 也不需要继承
				- static成员只能通过__className.成员Name__来使用，派生类可以使用__className.成员Name__来使用，(但终究不如直接成员Name用着爽，有什么办法吗？？？)
				- static成员本来的目的就是让__类和类的all实例__实时共享一组方法和数据 <- 往往是服务与同一项任务，而不是让类和子类也实时共享同一组方法和数据，因为子类之所以派生于父类往往是用于不同的任务，因为如果是同一任务没有必要在派生一个更复杂的子类的
	- 在存储上：
		- static成员是单独存储的(存储在哪里? 静态存储区？编译期间就存储的？是全局可用的吗？)，并不属于class的组成部分。
		- 由于static成员是与类分开单独存储(存储在静态存储区,编译期间确定？)的这一抽象意义 -> 本质上并不属于类和任一对象，故：
			- static成员在class声明完成的那一刻，便可以开始use 
			- 不能通过对象调用静态成员函数，只能通过类名来调用
				- 因为static成员本质上并不属于类和任一对象(而是编译期间存储在静态存储区，整个运行期
			- 不能使用this指针访问静态成员函数
				- 同样因为static成员不属于类or任何类的实例 -> 使用this是不合适的
			- 静态成员函数只能访问静态成员(静态数据成员or静态成员方法)[like const成员方法只能使用const成员]，普通成员函数访问普通的成员又能访问静态成员
				- 因为静态成员一旦声明完成就可以开始使用(even不需要class声明完) -> 使用static成员的时候可能类还没有创建实例这个时候普通成员可能还不存在


- static的推荐用法
	- 什么成员需要static修饰
	- static与const共同修饰？
	- static成员最好声明称public型
		- private型的static成员没有什么意义？？






### 成员访问限制符||friend
#### 成员访问限制符

#### friend
- 只有成员能使用访问限制符，class，struct前面不能使用访问限制符
- 访问限制符限制的是__外部类(包括亲子类)对类内成员的访问__
	- 同一类内的成员方法可随意访问任意限制级别的成员(方法or属性)，ru：构造函数调用成员
- 如何给成员设置最适合的访问限制？？private、public、protected
	- 根据场景和目的来设计

### 成员修饰符的顺序


### this指针

- this指针指向调用成员函数的对象
	- this作为隐藏参数传递给每个成员方法(包括构造函数&&析构函数)
	- 成员方法在参数列表中显式使用this指针
- 不使用this -> 成员方法如何return 此类本身？？

- 有时需要成员方法调用对象本身的需求
- 可使用 *this 引用整个调用对象

### 对象数组
- 声明对象数组 && 声明普通类型数组一样
```

```

- 如果只声明不显示给每个对象元素初始化，则总是调用默认构造函数
	- 如果给类显示定义了一个默认构造函数 (无参构造函数)，则原先的默认构造函数会被override

- 可使用构造函数来对整个数组进行初始化
	- 如果声明时不初始化 -> 全部采用无参默认构造函数初始化
	- 如果声明时只初始化了前面部分元素，剩下的采用默认构造
	- 可以对每个元素使用C11初始化列表来构造吗
```
	//声明，自动默认初始化
	People chinese[1300000000];
	//标准构造函数初始化
	People chinese[1300000000] = {People("wang"), People("li"), People("Kang"), ... , ,}
	//new版本
	People chinese[1300000000] = {new People("wang"), new People("Kang"), new People("Li"), ... , }
	//c11初始化列表版本
	People chinese[1300000000] = {{"Kang", "Hai"}, {"Li", "Hao"}, ... , }
	

```

- 初始化对象数组的背后机制
	- 1. 首先使用默认构造函数创建对象数组元素
		- 创建对象数组must类具有默认构造函数
	- 2. 然后右边花括号中的构造函数创建临时对象
	- 3. 将临时对象的内容复制到相应的元素中
		- 这个2，3很慢的 ，如何能避免使用？？？


### 作用域（D3种作用域）
- 全局(文件)作用域
- 局部(代码块，函数体)作用域
- 类作用域
- 1. 类内的成员名 (成员变量名、成员方法名) 的作用域是整个类 -> 在类外是不可知的，将导致下列三点
	- 1. 可以在不同类中使用相同的变量名
	- 2. 不能从外部访问类的成员 (public 的也不行)，必须通过对象来调用(实例化一个对象
	- 3. 
- 2. 作用域为类的const常量
	- 有时候每个类需要一组和类的生存周期相同的常量 -> 用来给生命周期为类作用域的类内成员(非static型)来使用
	- 创建一组每个对象独一份的常量
	- 创建一份所有对象共享的常量--static -- 常量的生命周期变成全局存在了，可见周期仍是类内可见？？__(like 函数体内的static那样？？不能在函数外(ru别的函数内使用))__，但是类内的static__为什么class一旦创建完成便可以到处使用了？？__

- 3. 创建一份所有对象共享的常量的方法
	- 使用 static (o)
	- 使用 enum (o)
	- 使用const int MatSize = 12 ;（x）
		- 声明类只是描述了对象的形式，并没有创建对象，在创建对象前，也没有用于存储值的空间
		- __const 不是 == const static吗？？？第九章讲的__
```
//使用const版是行不通的，
class test{

private:
	const int Month = 12;
	//因为此时class未真正创建 -> Month还未分配存储空间 -> 还未存在 -> gu,还不能使用
	double costs[Month];
}

//使用enum版
class test{

private:
	enum {Month = 12};
	//why枚举就会在类声明的时候便存在？？？
	double costs[Month];
}

//使用static版是行不通的，
class test{

private:
	static const int Month = 12;
	//因为此时class未真正创建 -> Month还未分配存储空间 -> 还未存在 -> gu,还不能使用
	double costs[Month];
}
```




## 类级的特点

### 类修饰符
#### 类访问修饰符
#### const
- 无const修饰的对象可以调用const && 非const成员(不会给对象or类的状态带来改变的方法or变量)，const修饰的对象只能调用const成员
	- 因为const修饰对象->对象状态不能变，但是调用非const成员无法保证不会改变对象的状态
- C++通过将const放在成员方法名后面 -> const型对象也可调用的不会改变对象状态的const成员方法

- to以防万一后续使用const修饰对象的问题 ->__ 一旦类方法不修改调用对象，就应将其声明为const__
#### static
### 抽象类
### 静态类



# 类间的关系
## is-a关系
## has-a关系


# 一个类的完整一生
## 声明类

## 创建类的实例
## 使用类
__c++的目标是使类的use与普通内置类型的use一致__

- 可以声明类对象
	- 声明的同时会进行默认构造初始化
	- 不使用new进行对象初始化，默认初始化创建的是局部对象
	- 使用普通显示(无new版的)创建的对象是局部 or heap上
```
//only声明->调用默认初始化->创建的是局部的对象(对象的作用域随他所在的局部范围而定)
People king;
//
People king = People();
//只要使用了new便是在heap上创建
People king = new People();
```
- 也可用new在堆上(动态存储区)给类开辟内存
- __因为想像普通内置类型一样使用类__ + __为了安全->类在使用前需要给属性成员初始化__+ __一般数据成员is private的，private只能通过成员方法来访问__-> 成员构造函数的产生

- __因为想像普通内置类型一样使用类__ + __有些类构造是会采用new在堆上开辟动态内存__ + __防止遗忘->内存泄露，要设置自动清理的功能__ --> 成员析构函数的产生
	- 如果类未使用new -> 清理时调用一个什么都不做的析构函数






__类成员方法如何操作多个对象(不只是操作他所在的类本身)__

- 1. class一旦开始声明，未声明完时便可在class内部使用这个类本身了
```
class People{
	
private:
	int year;

public:
	//找出年龄最大的类，并返回指向它的引用
	const People& maxNumPeople(const People& people[]){	//在People内部便开始使用People本身了
		if(){
        //code here
        return people[i]
        }else if{
		//...
		returnpeople[i]
		}else if{
		//...
		return this;
		}
	}
	
}
```



# C++的类风格指南
## google开源风格