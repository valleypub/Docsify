[toc]



# trivals


## 变量(对象)的使用方式
- 1. C++所有变量默认为值类型使用，除非使用  * （指针）、 &（引用） ,来显示指定
	- 对象值类型怎么使用的??

- 2. C#不同类型的变量的使用方式是一出生(声明)便固定的不可改变，只有：值类型、引用类型两种。



# C++11的易用性改进
## 自动类型推断

### auto

- 是什么
	- 自动类型推断，顾名思义，就是编译器能够根据表达式的类型，自动决定变量的类型（从 C++14 开始，还有函数的返回类型）

1. for()   foreach() 遍历、循环 配和auto auto& 来降低复杂、降低出错率
2. 模板 + auto 比只用模板通用性更高
- 模板 + auto
```c++
template <typename T>
void foo(const T& c)
{
  using std::begin;
  using std::end;
  // 使用依赖参数查找（ADL）；
  for (auto it = begin(c),
       ite = end(c);
       it != ite; ++it) {
    // 循环体
  }
}
```

- 只用模板，同样的功能，需要写两个
```c++
template <typename T, std::size_t N>
void foo(const T (&a)[N])
{
  typedef const T* ptr_t;
  for (ptr_t it = a, end = a + N;
       it != end; ++it) {
    // 循环体
  }
}

template <typename T>
void foo(const T& c)
{
  for (typename T::const_iterator
         it = c.begin(),
         end = c.end();
       it != end; ++it) {
    // 循环体
  }
}
```


### decltype （变量，表达式类型推断）
1. decltype(变量名)
2. decltype(表达式)
	- （表达式不是变量名，但包括 decltype((变量名)) 的情况）
	- 一般可以获得表达式的引用类型；除非表达式的结果是个纯右值（prvalue），此时结果仍然是值类型。
		- 如果我们有 int a;，那么：
		- decltype(a) 会获得 int（因为 a 是 int）
		- decltype((a)) 会获得 int&（因为 a 是 lvalue）
		- decltype(a + a) 会获得 int（因为 a + a 是 prvalue）。
3. decltype(auto) 。C++14 引入了 decltype(auto) 语法
	- decltype(expr) a = expr; 当expr特别长时这种写法不合适，需要改为下面的写法
	- 现在可以写为：
	- decltype(auto) a = expr;

### 函数返回值类型推断

从 C++14 开始，函数的返回值也可以用 auto 或 decltype(auto) 来声明了。


## 列表初始化
1. 数组自C98就支持列表初始化方式
```
int a[] = {1, 2, 3, 4, 5};
```


2. C++ 标准委员会引入了列表初始化，允许以更简单的方式来初始化对象。现在我们初始化容器也可以和初始化数组一样简单了。
	- 这不是对标准库容器的特殊魔法，而是一个通用的、可以用于各种类的方法。
		从技术角度，编译器的魔法只是对 {1, 2, 3} 这样的表达式自动生成一个初始化列表，在这个例子里其类型是 initializer_list。程序员只需要声明一个接受 initializer_list 的构造函数即可使用。从效率的角度，至少在动态对象的情况下，容器和数组也并无二致，都是通过拷贝（构造）进行初始化
```
vector<int> v{1, 2, 3, 4, 5};
```
而不用再用原先的下述初始化方式：
```
vector<int> v;
v.push(1);
v.push(2);
v.push(3);
v.push(4);
v.push(5);
```


## 使用大括号{}初始化代替小括号()初始化
几乎可以在所有初始化对象的地方使用大括号而不是小括号，而且还能避免很多问题
1. 避免了 C++ 里“最令人恼火的语法分析”
```
```


## 类数据成员的声明处初始化

C++11 增加了一个语法，允许在声明数据成员时直接给予一个初始化表达式。这样，当且仅当构造函数的初始化列表中不包含该数据成员时，这个数据成员就会自动使用初始化表达式进行初始化


## 字面量
### 普通的字面量
- 字面量（literal）是指在源代码中写出的固定常量，它们在 C++98 里只能是原生类型，如：
	- "hello"，字符串字面量，类型是 const char[6]
	- 1，整数字面量，类型是 int
	- 0.0，浮点数字面量，类型是 double
	- 3.14f，浮点数字面量，类型是 float
	- 123456789ul，无符号长整数字面量，类型是 unsigned long
	- 0xFF，十六进制字面量
	- 0 后面直接跟 0–7 的数字，八进制字面量
	- 0b111000000，二进制字面量
		- 从 C++14 开始，我们对于二进制也有了直接的字面量
		- I/O streams 里只有 dec、hex、oct 三个操纵器（manipulator），而没有 bin，因而输出一个二进制数不能像十进制、十六进制、八进制那么直接
			1. 一个间接方式是使用 bitset，但调用者需要手工指定二进制位数：
### 自定义字面量
C++11 引入了自定义字面量，可以使用 operator"" 后缀 来将用户提供的字面量转换成实际的类型。
C++14 则在标准库中加入了不少标准字面量。

#### how use
- 使用```operator"" 后缀```来声明一个自定义字面量后缀
- 使用  输入的值



## 数字分隔符
C++14 开始，允许在数字型字面量中任意添加```'```来增加可读性

具体怎么添加，完全由程序员根据实际情况进行约定。某些常见的情况可能会是：
1. 数字使用三位的分隔，对应英文习惯的 thousand、million 等单位。
2. 十进制数字使用四位的分隔，对应中文习惯的万、亿等单位。
3. 十六进制数字使用两位或四位的分隔，对应字节或双字节。
4. 二进制数字使用三位的分隔，对应文件系统的权限分组。
5. 等等。

一些实际例子如下：
```cassandra
unsigned mask = 0b111'000'000;
long r_earth_equatorial = 6'378'137;
double pi = 3.14159'26535'89793;
const unsigned magic = 0x44'42'47'4E;
```

## 静态断言
C++11 直接从语言层面提供了静态断言机制，不仅能输出更好的信息，而且适用性也更好，定义中，而不像之前用的特殊技巧只能放在函数体里。