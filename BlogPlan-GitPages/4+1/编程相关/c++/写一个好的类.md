[toc]


# 什么情况该使用OO

## OOP 是什么
__抽象__

- 生活中充满复杂&&错综 -> 处理复杂性的方法之一 is __简化&&抽象__
- 生活中的哪些可以抽象？抽象成什么？(class , interface , struct , )
- 哪些不可以抽象？why不可以?存在本质的东西-应该都能在编程中找到一一对应的项
- 
__继承__和__组合__
__封装__he__隐藏__

- 类的all公有部分构成 __公共接口__
- 类的all私有部分构成 __数据隐藏__
- 通常，数据成员放在私有部分，方法成员放在公有部分

__多态__

- 重载？
	- 方法重载
	- op重载
- 覆盖？

## how to 写一个 好的类
### 一个类的一切

#### __方法区__

##### 1. class的方法声明只能在类内部？(外部可以吗？) ， 方法定义在内部or外部都行
- 方法定义在类内部：默认is inline型的
	- 因为，inline只适用于很小的方法 ->__ 除非方法很小，否则不应该放在函数内部定义__
- 方法定义在类外部：默认is 回调型的，可通过显示 inline来定义成内联型
- 因为C++要求在每个使用内联函数的文件里都要有一份inline函数的定义 -> 类外部定义的inline成员方法要放到和class声明在同一个位置的文件里 (类内部定义的必然是符合的)

##### 2. 如何设计成员方法的签名？
- 如何设计输入参数列表？ -> 无参 or 值类型参数 or 引用类型参数
- 如何设计返回参数？ -> 无返回值 or 返回引用 or 返回指针 or 返回值 or 通过输入参数来返回？？
- 能不用参数就不用参数 -> if必须用参数, 能使用默认参数就使用默认参数 -> 引用参数 -> 

##### 如何设计成员方法的返回类型？
- 不要返回指向局部变量的引用
	- 如果must返回引用 -> 使用 new声明成动态存储区上的
- 局部对象通过值类型返回(创建临时对象返回)
	- 注意是 __深拷贝__ or __浅拷贝__

##### 构造函数(类的初始化与稳定)
- 3. 无法使用对象来调用构造函数 <- 因为在构造函数构造出对象前对象不存在
- 4. 构造函数必须在类声明or定义的时候使用
	- 显示调用
		- className objName;  objName = new className();
		- className objName = new className();
	- 隐式调用
	- className objNmae();

- C++11支持列表初始化 -> __1. 只要提供一个和某个构造函数的参数列表相匹配的内容__ + __2. 用括号括起来__
```
class Name{

private:
	Sring firstName;
	String secondName;

public:

	//构造函数
	Name(const string& firstName_, const string& secondName_ = " "){
		firstName = firstName_;
		secondName = secondName_;
	}
	//做好提供一个，默认无参的构造函数
	Name(){
		firstName = "none";
		secondName = "none";
	}
}

	//使用初始化列表进行初始化
	Name stu1 = {"Kang","kai"};
	//初始化列表也可以和默认参数配合使用
	Name stu2 = {"Xuan"}
```

- 5. to安全 --> 设计类时通常应重载一个无参默认构造函数为每个数据成员隐式初始化
- 同一个类的无参默认构造函数只能有一个，显式定义的无参默认构造会覆盖掉原本的默认构造函数
- (默认)构造函数对于一个类非常重要 -> 使一个类在声明-初始化后变得稳定，便于后续的使用
- 如对于一些ADT的设计时，(默认)构造函数非常重要

- 因为只能有一个析构函数，而构造函数可以有多个 -> 所有构造函数都要与析构函数兼容。
	- 如果在一个构造函数中使用了new (or new [] ) -> 析构函数中必须使用delete(or delete [] ), 为了防止对未new的进行delete ->必须all构造函数保持同步，一个使用了new(or new [])别的构造函数也要给同样的成员变量使用new(new [] )，即使以空的方式使用

- __C++11允许类内初始化(在类声明中进行初始化)__ 是怎么实现的？？也是通过底层的构造函数？？
	- 类内初始化与成员初始化列表等价
	- 使用成员初始化列表的构造函数将覆盖相应的类内初始化
```
	class People{
		
	public:
		//	c++11才允许这样初始化，之前一般是通过构造函数来初始化的
		String name = " ";
		int years = 25;
	}
```

9. 基类中__构造函数一旦使用new__ -> 需要进行一些连锁设置：
- 1. 析构函数中使用相应的delete
- 2. 别的构造函数中保持同步的方式使用new(可以使用空的nullptr)
	- 防止，对未new的内存区使用delete
- 3. 显示定义复制构造函数&&重载赋值运算符(对于new相关的成员 or 引用类型的成员(string、class类型的) -> 改为深复制版的)
	- 因为如果使用默认的复制构造函数和默认赋值运算符的__浅复制__ 对于new，delete -> 会导致同一块内存多个指向 -> delete多次 or delete不同步( -> 乱码)的问题


##### 析构函数
6. 与构造函数不同的是 -> 析构函数没有参数，析构函数只能有一个，不能被重载
7. 析构函数的调用is编译器自动执行的不像构造函数要手动来
	- 通常不应在代码中显式调用析构函数 (除非类使用new来构造的对象) 。why??? 说明可显式调用
	- 如果对象是new创建的在__动态存储去__中 -> must使用delete来主动析构
	- 如果实例化的对象在__静态存储区__(static，or 在all函数外声明(== 全局的，全局的变量or对象存在静态存储区)) -> 程序结束时调用析构函数
	- 如果实例化的对象在__自动存储区__(局部的) -> 程序执行完其声明所在de代码块时调用析构
	- 对于没有名字的临时对象( className(，，) ) -> 在结束该对象的使用时自动调用析构函数
8. 构造函数中使用new来分配内存时，必须在相应的析构函数内使用delete来释放内存(如果使用 new type[], 必须使用 delete[] )
- 因为只能有一个析构函数，而构造函数可以有多个 -> 所有构造函数都要与析构函数兼容。
	- 如果在一个构造函数中使用了new (or new [] ) -> 析构函数中必须使用delete(or delete [] ), 为了防止对未new的进行delete ->必须all构造函数保持同步，一个使用了new(or new [])别的构造函数也要给同样的成员变量使用new(new [] )，即使以空的方式使用

#####  __const成员__
- 无const修饰的对象可以调用const && 非const成员(不会给对象or类的状态带来改变的方法or变量)，const修饰的对象只能调用const成员
	- 因为const修饰对象->对象状态不能变，但是调用非const成员无法保证不会改变对象的状态
- C++通过将const放在成员方法名后面 -> const型对象也可调用的不会改变对象状态的const成员方法

- to以防万一后续使用const修饰对象的问题 ->__ 一旦类方法不修改调用对象，就应将其声明为const__


##### __static成员__
- why need static：
	- 类中的static成员和裸的static(变量or方法)还不太一样：
		- 裸的static(变量or函数)中的static主要是用于限定 存储位置、确定时间 && 链接性(外部链接or内部链接)
		- 但是，类中的static主要用于模拟__类和all实例的对象共用同一分备份__的情况
			- 通过static是存储在静态存储区(一个不属于类和all对象的地方)来实现 -> all实例对象&&类共同维护同一个内存区域
				- 由于，static -> 静态存储区 -> 编译器期间分配内存 -> 类一旦声明好不与要实例化成对象，就可以开始使用static成员了

1. 类静态数据成员在类声明中声明，在include类声明文件的文件中初始化。（可以在类外声明吗？）
- 静态类成员__不能在类声明中初始化__，必须在类声明外部初始化。(有没有位置限制？必须在类声明的外部上方？)
- 静态类成员的__初始化位置__必须在方法文件中，而__不能在类声明所在的头文件中(class所在的那个头文件)__。
	- 这一点和inline成员完全相反
	- static成员是单独存储的(存储在哪里? 静态存储区？编译期间就存储的？是全局可用的吗？)，并不属于class的组成部分。
	- 由于inline的特殊要求(每个使用inline的地方都要包含一份inline函数的定义，哪怕一样) -> inline放置在class声明所在的文件是最好的，每当class被include时，inline方法同时也被include
	- 除了inline之外的方法都是要遵循ODR(One Definition Rule), static限制的也不例外，因为class声明可能会被多个文件include(声明可以多次)，故普通定义不能放置在可能会被多次include的文件中(inline例外)
- 静态类的外部初始化时，不需要带上static，但必须使用作用域运算符指出所属的类
2. 如果静态成员是 const修饰的 (整数类型 or 枚举类型)，可以在类声明中初始化。why？？？？
3. 由于static成员是与类分开单独存储(存储在静态存储区)的这一抽象意义 -> 本质上并不属于类和任一对象
- static成员在class声明完成的那一刻，便可以开始use  
- 不能通过对象调用静态成员函数，只能通过类名来调用
	- 因为static成员本质上并不属于类和任一对象(而是编译期间存储在静态存储区，整个运行期间存在的类的外部)，故不能通过对象来调用
- 甚至不能使用this指针访问静态成员函数，最好不要使用this指针访问静态成员
- 静态成员函数只能使用静态数据成员


##### 特殊成员函数
- C++会自动提供下面这些成员函数
1. 默认构造函数，如果没有定义构造函数
2. 默认析构函数，如果没有定义
3. 复制构造函数，如果没有定义
- Class_name(const Class_name &);
- 对于复制构造函数，需要知道两点：何时调用和有何功能。
	- 何时调用：
		- 1. 新建一个对象并将其初始化为同类现有对象时
		- 2. 无论哪种编译器，当按值传递和返回对象时，都将调用复制构造函数。
			- 按值传递意味着调用复制构造函数创建一个原始变量的副本。
			- 应尽量使用引用传递对象来节省空间和时间
		- 3. 编译器生成临时对象时，也将使用复制构造函数
			- 例如将3个 vector对象相加时，编译器可能生成临时的vector对象来保存中间结果。
	- 有和功能：
		- 默认的复制构造函数逐个复制非静态成员，复制的是成员的值(也称为浅复制)
			- 如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象(这不是深复制吗？？？不是，如：string类型成员存储的是一个地址，复制的时候只会将这个成员值复制过去，而不会将指向的字符串内容复制过去)
		- 静态成员属于整个类而不是各个对象，不变。
```
//这3种是复制构造
Class_name obj1(obj2);
Class_name obj1 = Class_name(obj2);
Class_name * obj1 = new Class_name(obj2);
//这种可能采用复制构造，也可能采用赋值运算符
Class_name obj1 = obj2;
```

- better__禁用默认复制构造函数__&&__定义一个显式复制构造函数__ <- because 默认复制构造函数可能会造成严重的问题 
	- 如：因为是浅复制，会将指向字符串的地址返回一份，但是如果原对象被析构了，会导致：
		- 新对象的字符串成员指向的位置会无效，返回一个奇怪的结果
		- 释放同一内存两次可能导致程序异常终止
	- 对于上述问题，直接定义一个显式的复制构造函数来进行字符串的深度copy -> 每个对象都有自己的字符串而不是指向别的对象的字符串
	- 其实对于__存在使用new创建的成员的类都应该显示重定义复制构造函数__+__使深度copy__ -> 来避免上述问题

4. 赋值运算符，如果没有定义
- ANSI C允许解构赋值，C++允许类对象赋值
- Class_name & Class_name::operator=(const Class_name &);
- 对于赋值运算符，也需要知道两点：何时调用和有何功能。
	- 有和功能：
		- 默认的赋值运算符逐个复制非静态成员，复制的是成员的值(也称为浅复制)
			- 如果成员本身就是类对象，则将使用这个类的赋值运算符来复制成员对象
		- 静态成员属于整个类而不是各个对象，不变。
	- 何时调用：
		- 将已有的对象赋给另一个对象时，将使用重载的赋值运算符 != 在初始化的时候使用 = 
```
//使用assign operator
Class_name obj1;
obj1 = obj2;
//在同一行会使用复制构造函数
Class_name obj1 = obj2;
```

- 默认的赋值运算符会带来和赋复制构造相似的问题，解决办法如下：
	- 1. 从源头避免: 应避免将对象赋给自身 ，尽量使用对象的引用来代替
	- 2. 如果无法从源头避免 -> __使用显式重定义赋值运算符__ + __深度copy__来做

5. 地址运算符，如果没有定义

###### C++11还提供了另外两个特殊成员函数
1. 移动构造函数
2. 移动赋值运算符

#### __OP重载区__
__一般内置的op都是针对一些内置类型的__(ru : + - * -> 数字类型 ，+ “ ” -> string类型)，而class这种自def类型一般是没有op可以使用，除非在类内对op重载。struct可以含有op重载吗？？

##### __OP重载 和 成员方法de写法高度一致__
- 1. 定义的时候：只要将 __成员方法名 -> operatorOP__ 别的输入参数列表、返回类型、限制符都不用改
	- 也就是说，op重载能实现的 使用 新命名一个成员方法 都能实现
		- 将成员方法名 换成 op 只是符合多年C的使用习惯，功能是一样的
```

```

- 2. 调用的时候： 有2种调用方式
	- 1. 类成员方法式使用：C = A.operator+(B)，
	- 2. 类C式使用 ： C = A + B;
	- op重载符在使用时会被转换成函数调用？？
```
	Time A,B,C;
	C = A + B;
	// + 会被转换为
	C = A + B -> C = A.operator+(B);//像成员函数一样的用法
```

##### __重载限制__

__使用运算符不能违反运算符原本的句法规则__

- 因为原本成员方法is够用的，之所以使用op重载 -> 只是want以原先的op句法规则的方式use成员方法
	- 如果句法规则都该就没有什么意义了

__不能创建新的OP运算符__

- ru: 不能定义 operator** ()
- 

__现有的OP__

- 不能重载的OP
	- __sizeof()__
	- __.__
	- __. *__
	- __::__
	- __?:__
	- __typeid__
	- __const_cast__
	- __dynamic_cast__
	- __reinterpret_cast__
	- __static_cast__

- 能重载的OP
	- 只能通过成员函数重载的OP
		- __=__
		- __( )__
		- __[ ]__
		- __->__
	- 成员、非成员函数方式都能重载的OP
		- 


#### 访问限制符&&friend(开特权，朋友是知道你秘密最多的人)

- 只有成员能使用访问限制符，class，struct前面不能使用访问限制符
- 访问限制符限制的是__外部类(包括亲子类)对类内成员的访问__
	- 同一类内的成员方法可随意访问任意限制级别的成员(方法or属性)，ru：构造函数调用成员
- 如何给成员设置最适合的访问限制？？private、public、protected
	- 根据场景和目的来设计


#### __多副本__or__单副本(static)__(all对象&&类本身->共享同一副本)

- 同一类的不同对象间的成员可以单副本or多副本
	- 默认is多副本的
	- 使用static强行全局存在==共享唯一副本
		- static属性一旦class声明后就存在了,就可以开始使用(即使还没有进行实例化)，可以通过  className.成员Name 来随意使用
- 同一类的不同对象间共享同一组成员方法组
	- 默认is单副本的 ---- 那和static声明的方法有何区别???
		- static全局存在一旦class创建好 -> 就可以随意使用，而默认的要实例化来使用


#### __this指针__

- this指针指向调用成员函数的对象
	- this作为隐藏参数传递给每个成员方法(包括构造函数&&析构函数)
	- 成员方法在参数列表中显式使用this指针
- 不使用this -> 成员方法如何return 此类本身？？

- 有时需要成员方法调用对象本身的需求
- 可使用 *this 引用整个调用对象

#### __对象数组__

- 声明对象数组 && 声明普通类型数组一样
```

```

- 如果只声明不显示给每个对象元素初始化，则总是调用默认构造函数
	- 如果给类显示定义了一个默认构造函数 (无参构造函数)，则原先的默认构造函数会被override

- 可使用构造函数来对整个数组进行初始化
	- 如果声明时不初始化 -> 全部采用无参默认构造函数初始化
	- 如果声明时只初始化了前面部分元素，剩下的采用默认构造
	- 可以对每个元素使用C11初始化列表来构造吗
```
	//声明，自动默认初始化
	People chinese[1300000000];
	//标准构造函数初始化
	People chinese[1300000000] = {People("wang"), People("li"), People("Kang"), ... , ,}
	//new版本
	People chinese[1300000000] = {new People("wang"), new People("Kang"), new People("Li"), ... , }
	//c11初始化列表版本
	People chinese[1300000000] = {{"Kang", "Hai"}, {"Li", "Hao"}, ... , }
	

```

- 初始化对象数组的背后机制
	- 1. 首先使用默认构造函数创建对象数组元素
		- 创建对象数组must类具有默认构造函数
	- 2. 然后右边花括号中的构造函数创建临时对象
	- 3. 将临时对象的内容复制到相应的元素中
		- 这个2，3很慢的 ，如何能避免使用？？？


#### __作用域__（D3种作用域）

- 全局(文件)作用域
- 局部(代码块，函数体)作用域
- 类作用域
- 1. 类内的成员名 (成员变量名、成员方法名) 的作用域是整个类 -> 在类外是不可知的，将导致下列三点
	- 1. 可以在不同类中使用相同的变量名
	- 2. 不能从外部访问类的成员 (public 的也不行)，必须通过对象来调用(实例化一个对象
	- 3. 
- 2. 作用域为类的const常量
	- 有时候每个类需要一组和类的生存周期相同的常量 -> 用来给生命周期为类作用域的类内成员(非static型)来使用
	- 创建一组每个对象独一份的常量
	- 创建一份所有对象共享的常量--static -- 常量的生命周期变成全局存在了，可见周期仍是类内可见？？__(like 函数体内的static那样？？不能在函数外(ru别的函数内使用))__，但是类内的static__为什么class一旦创建完成便可以到处使用了？？__

- 3. 创建一份所有对象共享的常量的方法
	- 使用 static (o)
	- 使用 enum (o)
	- 使用const int MatSize = 12 ;（x）
		- 声明类只是描述了对象的形式，并没有创建对象，在创建对象前，也没有用于存储值的空间
		- __const 不是 == const static吗？？？第九章讲的__
```
//使用const版是行不通的，
class test{

private:
	const int Month = 12;
	//因为此时class未真正创建 -> Month还未分配存储空间 -> 还未存在 -> gu,还不能使用
	double costs[Month];
}

//使用enum版
class test{

private:
	enum {Month = 12};
	//why枚举就会在类声明的时候便存在？？？
	double costs[Month];
}

//使用static版是行不通的，
class test{

private:
	static const int Month = 12;
	//因为此时class未真正创建 -> Month还未分配存储空间 -> 还未存在 -> gu,还不能使用
	double costs[Month];
}
```



#### 类的use

##### c++的目标是使类的use与普通内置类型的use一致

- 可以声明类对象
	- 声明的同时会进行默认构造初始化
	- 不使用new进行对象初始化，默认初始化创建的是局部对象
	- 使用普通显示(无new版的)创建的对象是局部 or heap上
```
//only声明->调用默认初始化->创建的是局部的对象(对象的作用域随他所在的局部范围而定)
People king;
//
People king = People();
//只要使用了new便是在heap上创建
People king = new People();
```
- 也可用new在堆上(动态存储区)给类开辟内存
- __因为想像普通内置类型一样使用类__ + __为了安全->类在使用前需要给属性成员初始化__+ __一般数据成员is private的，private只能通过成员方法来访问__-> 成员构造函数的产生

- __因为想像普通内置类型一样使用类__ + __有些类构造是会采用new在堆上开辟动态内存__ + __防止遗忘->内存泄露，要设置自动清理的功能__ --> 成员析构函数的产生
	- 如果类未使用new -> 清理时调用一个什么都不做的析构函数






##### 类成员方法如何操作多个对象(不只是操作他所在的类本身)

- 通过__class一旦开始声明，未声明完时便可在class内部使用这个类本身了__这个特点
```
class People{
	
private:
	int year;

public:
	//找出年龄最大的类，并返回指向它的引用
	const People& maxNumPeople(const People& people[]){	//在People内部便开始使用People本身了
		if(){
        //code here
        return people[i]
        }else if(){
		//...
		return people[i]
		}else if(){
		//...
		return this;
		}
	}
	
}
```




### 类 && 动态内存分配

1. 动态内存分配思想 && 静态内存分配思想
- 静态分配
	- 缺点
		- 不适用于动态变化剧烈的情况。如，每顿吃什么、磁盘该划分多大
	- 优点
	- 例子：
		- 磁盘分区的划分
		- 食物的一月一次性购买
		- 
- 动态分配
	- 优点
	- 缺点
	- 例子
		- 磁盘only一个分区，用文件夹代替分区，可动态调整大小


2. 类内成员的声明-初始化位置
- 任意限制(static ， cosnt, )的类成员(成员，方法)__声明位置__均可在类内，可以在类外用 className::成员名 声明吗??
- 类成员的__初始化位置__有区别：
	- 普通成员： 初始化可以在类内、类外(className::成员名 )均可
	- static成员:   必须在类外进行初始化 why??? , 但有一种例外。
		- static + const+整数类型 or 枚举类型： 可以在类内也可以在类外定义，why???
		- b


### 类间的关系
#### 继承
##### 3种派生方式
###### public派生
1. 建立一种 is-a的关系
- "是"的关系
	- 派生类对象也是一个基类对象
	- 新类将继承基类的所有数据成员 ,static数据成员也继承？方法成员也不被继承？
	- is-a关系通常是不可逆的。也就是说，香蕉是水果，水果不是香蕉
2. 多态公有继承
- 一般派生类对象使用基类中的方法，而未做任何修改。然而，有时希望同一个方法在派生类和基类中的行为是不同的
- 方法的行为应取决于调用该方法的对象(而不应是指针or引用的类型)，这种复杂的行为is called ：多态
	- 本质上多态的复杂性is由于 基类型 可以作为 派生类型和基类型的入口 这一单向的例外 导致的？？
- 实现多态公有继承的2种重要机制：
	- 在派生类中重新定义(覆盖，override)基类的方法
	- 使用虚方法(virtual)
		- 如果方法是通过引用or指针而不是对象(值类型)调用的，virtual机制将确定使用哪一个类中的方法(基类or派生类、、)
			- 如果没有使用关键字virtual，程序将根据引用类型or指针类型来选择方法
				- 因为无virtual -> 不允许override重写 -> 只有一个类有完全匹配的 (函数名+ 输入参数列表)
			- 如果使用关键字virtual，程序将根据引用or指针指向的对象的类型来选择方法
				- 因为virtual标志方法可以被override重写( != 重载，函数名、输入参数列表一样)，故不是只有一个类可以拥有匹配的(函数名+输入参数列表的方法)，调用的是指针具体指向的类中的那个

- 如果要在派生类中重新定义基类的方法，应将基类方法声明为virtual虚的
	- 这样，程序将根据引用or指针所指向的类型，而不是引用or指针的类型来选择方法的版本

- 为基类声明一个虚析构函数
	- 如果析构函数不是虚的，则将只会调用对应于指针类型的析构函数（而不管指针类型指向的是指针类型的对象 or 指针类型的派生类类型的对象，即不考虑指针类型可作为入口的复杂性）
		- 如：基类指针指向派生类对象；但只会执行指针类型(即基类类型)的析构函数，而不会考虑真正指向的对象是派生类类型对象
	- 如果析构函数是虚的，将会调用指针所指向的对象类型的析构函数
		- 如：基类指针指向派生类对象 -> 则虚析构会先执行派生类的析构函数 -> 在自动调用基类的析构函数
		- 即虚析构函数可以保证正确的析构函数序列被调用

###### private派生
1. has-a的关系
2. 基类的公有成员和保护成员都将成为派生类的私有成员(但继承的基类的私有成员仍是一个无钥匙的宝箱 并不是 派生类的私有成员)
- 这意味着基类方法(公有成员和保护成员)将不会成为派生对象公有接口的一部分，只可以在派生类的成员函数中使用它们
- 和成员对象(复合关系)还不太一样，
	- 成员对象的(公有成员)可以被拥有它的类的all方法访问，protected成员可以被访问吗？
	- 成员对象放置在public区，可以被派生类的外部的类使用吗？
3. 使用private继承的基类的方法
- 使用私有继承时，只能在派生类的方法中使用基类的(非私有)方法
- 有时希望基类的成员是共有的
	- 可以在派生类中使用一个公有函数来封装私有基类函数的方式来提供一个相同功能的公有接口

4. 私有继承使得在派生类中能够使用类名和作用域解析运算符来调用基类的方法 (!= 复合关系的 成员对象名的方式使用)，ru:  baseClassName.成员名()的方式来

5. 访问派生类中私有继承的基类对象的那一部分
- 使用强制类型转换的方式，在派生类中将 *this -> 强制类型转换为继承的基类 -> （const baseClassName &）
	- 就像，按成员对象的方式使用私有继承的基类
```
	class people{
	private:
		string name;
	public:
	
	}
	
	class chinese : private people{
	
	pubic:
		//将派生类对象 ->强制类型转换-> 成员基类的对象
		//按成员对象的方式使用私有继承的基类
		const people & mypeople = (people &) *this;
		//
		const people & Name() const
		{
			return (const people &) *this;
		}
	}
```


6. 访问基类的友元函数

7. has-a关系有两种建立方式: 私有继承、复合包含
- 1. 通常应使用复合来建立has-a关系
	- 继承会引起很对问题：
		- 1. 
- 2. 如果新类需要访问原有类的__保护成员__or__重新定义虚函数__则应使用私有继承

###### protected派生



##### 派生具体发生了什么
0. 继承一个类是直接拥有一个类的什么？
- 拥有基类的哪些部分？
	- 属性区
	- static成员怎么派生？
	- 方法区会被继承吗？
- 继承的部分和新增的部分是怎么在内存中存储的？存储的相对关系是怎样的？继承的存储在新增的上方？连续存储吗？

1. 派生类对象存储了基类的数据成员
- static成员是怎么继承的？
- 
2. 派生类对象可以使用基类的方法

##### 派生类的新增区要添加什么
1. 要添加自己的构造函数
- 构造函数不能继承。因为类名不同 -> 构造函数名字不同？
- 派生类的构造函数要做的工作
	- 给__新成员__提供数据(对新成员初始化)
	- 给__继承的成员__提供数据(对子类的成员也要进行初始化) why???
- 派生类构造函数必须使用__基类构造函数__
	- 派生类不能直接访问基类的私有成员，必须通过基类非私有方法进行访问，但是私有基类成员也需要初始化，只能通过基类构造函数来进行
	- 派生类构造函数if不在初始化列表中显式调用基类构造函数，程序将在初始化列表中使用基类的默认构造函数
		- 除非要使用默认构造函数，否则应显式调用正确的基类构造函数
	- 基类的构造函数要放在派生类的初始化列表的前方
		- 如果是多基类派生，要将所有的基类的构造函数放在派生类的初始化列表的前方
- 派生类的初始化列表中也可以调用基类的复制构造函数来对基类的成员进行初始化
- 进入派生类构造函数的初始化列表( 各基类的构造函数都在初始化列表中 )  !=  调用了派生类的构造函数？？
- 派生类的构造函数总是调用一个基类构造函数：如果不显式指明，则调用默认的基类构造函数

2. 要添加自己的析构函数？
- 析构函数也不能被继承
- 但如果基类有默认析构函数，编译器将为派生类生成默认析构函数
	- 如果基类的析构is virtual析构 ， 编译器为派生类生成的析构is 虚析构吗？？？？

3. 释放对象的顺序和创建对象的顺序相反
- 派生类创建对象的顺序：
	- 1. 先调用各基类构造函数 -> 创建各基类
		- 进入派生类构造函数的初始化列表( 各基类的构造函数都在初始化列表中 )  !=  调用了派生类的构造函数？？
		- 如果多个基类，各基类的顺序怎么定？
	- 2. 再创建派生类
- 派生类释放对象的顺序
	- 1. 先执行派生类的析构函数 -> 
	- 2. 再自动调用基类的析构函数
4. 可以根据需要添加额外的数据成员和成员函数

5. 赋值运算符也不能被继承
- 因为，派生类继承的方法的特征标与基类完全相同，但赋值运算符的特征标随类而异，这是因为它包含一个类型为其所属类的形参
- 编译器会使用基类的默认赋值运算符来处理派生类对象中基类部分的赋值，如果显示的为基类提供了赋值运算符，将使用该运算符代替基类默认的
- 如果派生类成员is另一个类的对象，对于该成员，将使用其所属类的赋值运算符
6. 友元不能被继承
##### 派生类&&基类放置的位置
1. 两个类的类声明( class { } )的放置位置
- 使用派生类，程序必须能够访问基类声明。
- 将这两种类的声明置于同一个头文件中
- 也可以将两个类放置在独立的头文件中，但由于这两个类是相关的，所以把其类声明放在一起更合适
2. 两个类的定义的放置位置
- 将两个类的定义 (外部定义) 放置在一个文件也更简单合理

##### 派生类&&基类的特殊关系
1. 派生类可以使用基类的非私有成员(public成员、proected成员)
- 类的私有成员之所以设置成私有的is有其道理的，不能被别的类访问，一定是通过别的方式来被使用的
2. C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是例外
- 基类指针(引用)可以在不进行显式类型转换的情况下指向(引用)派生类对象
	- 但是，基类指针(引用)只能用于调用派生类中的继承的基类区中的方法
- 这种例外是__单向的__
	- 可以基类 -> 指向 -> 派生类，小的可以指向大的( == 大的可以赋给小的指针变量)
	- 但反过来就不行 ，基类 <- 指向 <- 派生类
- 这种例外产生有用的应用：
	- 1. 基类指针(引用)做基类or派生类的入口

##### 静态联编和动态联编
- Q: 程序调用函数时，将使用哪个可执行代码块？
- A: 编译器负责回答这个问题，将源代码中的函数调用解释为执行特定的函数代码块被称为__函数名联编(binding)__
1. C语言中binding非常简单，(因为没有重载)，每个函数名都对应一个不同的函数。也是在编译期间进行的binding????
2. C++中存在__函数重载__ -> 任务更复杂 -> 编译器must使用 (函数名 + 参数列表)来确定使用的是哪个函数。C++编译器可以在编译过程中完成这种binding
3. 由于C++除了函数重载，还存在__虚函数机制__ -> 任务更更复杂，因为在编译期间不确定指针使用哪种类型对象(是基类or派生类)的函数 -> 编译器必须生成能够__在程序运行时选择正确的虚方法的代码__，这被称为__动态联编__
	- why virtual的使用导致 动态联编的出现？
		- 因为virtual的存在是为了"重写"(函数名，输入参数列表完全一样，比重载更难区分，故不能使用静态联编)而不是"重载"（重载可以使用静态联编）
	- virtual使允许子类对基类的成员函数进行重写 + 基类可以做子类入口的特性(即，由于基类指针既可以指向基类对象 又 可以指向 子类对象的这一灵活的用法导致的) -> 无法使用签名(函数名 + 输入参数列表)来确定调用哪个(因为，子类和父类具有同签名但定义不同的方法) -> 此时使用虚函数表机制()来进行动态联编

- 静态联编(static binding)：又称早期联编
	- 在编译的过程中完成的联编binding
	- 编译器对非虚方法使用静态编译(因为不适用virtual -> 不存在函数名 + 参数列表一样的不同方法 -> 在编译期间就能完全确定使用的方法)
- 动态联编(dynamic binding) :
	- 编译器对虚方法使用动态binding

###### 1. 编译期间&&运行期间 可见的不同
1. 编译期间可见&&不可见的：
- 可见的：
	- 类型的声明：如：class的声明
	- 方法的声明？
	- 指针的类型
- 不可见的：
	- 变量or对象的类型
2. 运行期间可见的：
- 各变量

###### 2. 指针和引用类型的兼容性
1. 一般C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型；__但公有继承的基类指针or引用是例外__
2. 由于公有继承的is-a关系 -> 隐式向上转换&&显式向下转换
- 向上转换：
- 显示向下转换：
	- 因为 is-a关系通常是不可逆的，即单向的 ->  
3. 正是共有继承的基类指针or引用的例外情况 -> 多态的存在 -> 引入binding上的复杂 -> 动态联编&&虚函数机制

###### 3. C++使用的2种联编&&默认的联编方式
1. 目前C++结合使用两种binding方式：静态binding、动态binding
2. 默认的binding方式是静态binding，静态联编做不到的才使用动态联编
- 1. 如果不使用类的继承功能
- 2. 如果派生类中不对基类中的方法进行override
- 3. 1.2.是不需要使用低效的动态联编的

3. 既然动态联编如此强大为什么不设置为默认的binding方式？那样不就只需要使用一种binding方式了吗？
- 效率
	- 不要为不使用的特性付出代价，因为大部分时候不需要使用virtual -> 静态联编足以，强行一股脑使用动态binding反而会降低效率
	- 为使程序能在运行阶段进行决策 -> 必须使用一些方法来跟踪基类指针or引用指向的对象模型 -> 增加额外的处理开销
- 概念模型

###### 静态联编原理

###### 动态联编原理(虚函数的工作原理)
1. 虚函数的工作原理
- C++规定了虚函数的行为，但将实现方法留给了编译器作者
2. vtbl
3. virtual机制的例外
- 1. virtual析构函数
	- 一般需要在派生类中对方法进行覆盖 -> 在vtbl中用派生类的函数code地址覆盖掉相应的基类的函数code的地址
	- 但对于析构函数，只需要基类中显示 virtual析构 ，派生类中使用默认的why也可以实现覆盖？？


###### 虚函数的注意事项
1. 构造函数
- 构造函数不能是虚函数。

2. 析构函数
- 析构函数最好声明为virtual，除非确定不做基类
- 析构函数最好统统写为virtual型，来替代原本的默认析构函数，即使他什么也不做，总没有坏处

3. 友元
- 友元不能是虚函数，因为友元不是类成员，只有类成员才能是虚函数

4. 没有重新定义
- 如果派生类没有重新定义函数，将使用该函数的基类版本

5. 重新定义将隐藏方法
- 1. 派生类中的方法__只要方法名一样__(而不需要__方法名+输入参数列表__均相同)就会覆盖override掉基类中的同命方法，而不会重载
- 2. 如果基类中重载了多了方法，如果只重定义(只需名字一样)其中一个 -> 基类中所有同名的方法也会被all覆盖隐藏，派生类无法使用它们 -> 故，应在派生类中重新定义同名方法的所有的基类版本
- 派生类中的新增区中应该可以重载多个不同版本的方法吧？因为并不会涉及到基类中的方法
- 单个类中的只有签名(方法名+输入参数列表)一样才会进行覆盖，否则只是重载

6. 返回类型协变(covariance of return type)

#### 复合
1. has-a的关系

2. 初始化被包含的成员对象
- 1. 使用初始化列表的方式
	- 和__继承__中一样，使用构造函数的成员初始化列表来初始化成员对象
	- 不同的是，继承使用基类名来、复合使用成员对象的对象名
	- 但，初始化列表中的每一项都调用各自的构造函数来进行初始化
- 2. 不使用初始化列表的方式
	- C++规定在构建派生类对象的其他部分之前，先构建派生类对象的所有成员对象(使用各成员对象所属类的默认构造函数)
```
	class base{
	public:		
		base(){
		
		}
	}
	class son : base{
	private:	
		Gun toyGun;	
	public:		
		//一个使用类名，一个使用对象名
		son(int a,int b) :base(a),toyGun(b){
		
		}	
	}
```

- 3. 初始化列表包含多个项目时，这些项目被初始化的顺序为它们在类中被声明的顺序，而不是它们在初始化列表中的顺序
	- 对于那些不在类中进行声明的顺序是怎样的？如：继承的__基类__ 与 复合的__成员对象__ 谁先初始化

3. 使用成员对象的接口
- 1. 拥有成员对象的类本质上相当于成员对象的外部 -> 只能使用成员对象的公共接口？
- 2. 只有拥有成员对象的类的类内方法可以使用成员对象的公开接口？
	- 可不可通过 __拥有成员对象的类对象名.成员对象.成员名__ 的方式来使用成员对象？
		- 如果将成员对象访问控制设置为public型 -> 拥有成员对象的类对象名.成员对象  这一步是可行的 应该就可以把？



### 继承与动态内存分配
- 继承是怎样与动态内存分配(使用new和delete)进行互动的呢？
- 如果基类未使用动态内存分配，此时会如何影响派生类实现呢？
- 如果基类使用动态内存分配，并重新定义赋值和复制构造函数，这将怎样影响派生类的实现呢？

1. 基类中构造函数一旦使用new -> 需要进行一些连锁设置：
- 析构函数中使用相应的delete
- 别的构造函数中保持同步的方式使用new(可以使用空的nullptr)
	- 防止，对未new的内存区使用delete
- 显示定义复制构造函数&&重载赋值运算符(对于new相关的成员 or 引用类型的成员(string、class类型的) -> 改为深复制版的)
	- 因为如果使用默认的复制构造函数和默认赋值运算符的__浅复制__ 对于new，delete -> 会导致同一块内存多个指向 -> delete多次 or delete不同步( -> 乱码)的问题
#### 派生类不使用new

1. 不管基类中是否使用了动态内存分配(new,delete)，不需要在派生类中定义显式析构函数、复制构造函数、和重载赋值运算符
- 1. 不需要显式定义析构函数,使用派生类默认的即可
	- 只要基类中的析构使用了virtual -> 派生类的默认析构就会：1. 先执行自身的析构代码 -> 2. 再调用基类的析构
	- 需要派生类中显示virtual析构吗?，不需要。只要基类使用virtual析构，派生类中使用默认隐式的，使用基类的指针引用的兼容问题是，也能保证正确的析构顺序
- 2. 

#### 派生类使用new





### 抽象基类
1. 纯虚函数声明的结尾处为 =0
```
	class people{
	public:
		virtual double Area() const = 0;
	}
```
2. 抽象基类只用作基类(只能被继承使用)，不能创建该类的对象
- 至少含有一个纯虚函数( =0)的类是抽象基类
- C++甚至允许纯虚函数有定义
	- 因为有时有些方法是功能都一样的 -> 只需要在抽象基类中定义一次，在别的派生类中使用即可
- 类声明中包含纯虚函数时 -> 不能创建该类的对象







### 我有两个盒子和一个屋子
- 更高优先级可见 -> 一定低优先级的也可见
##### private宝箱
- 这个箱子藏着我最隐蔽的、不堪回首的过去，不可被家人，公众知道
- 只有我和我的friend有这个箱子的钥匙，可以访问这里的东西
- 我的孩子可以通过继承拥有这个宝箱，但是无法打开它，查看他
##### protected宝箱
- 是我想留给我的孩子的东西，钥匙是她的生日密码
- 钥匙只有我，我的friend，我的孩子知道，我们都可以访问箱子里的内容
- protected虽可以简化代码的编写工作，但本身是有设计缺陷的
- 最好对数据成员private访问控制，通过方法来访问数据
##### public屋子
- 




### 组合 or 继承？？
#### why java 不支持 多继承？？？(该不该用多继承？？)
- __多继承__可以  -> __单继承+组合__
	- ru: 大学生即是人又是学生，但是可以抽出一个做主体来继承(is的关系)，别的做拥有的身份(有的关系)

```
class people{

	泌尿系统；
	生殖系统;
	呼吸系统; （这种实体）
}

class Identity{

}

class Graduate : public people{
	//拥有一个身份，
	Identity myIdentity;

}

```

- 生活中的哪些可以抽象成类？怎么抽象？

- 哪些不可以抽象成类？why不可以



## 类设计回顾

## else

#### __class__与__struct__的区别

1. class的成员默认is private, struct的成员默认is public

#### 为什么要进行代码复用
1. 重用经过测试的代码比重新编写代码要好：
1. 可以节省时间
2. 可以节省错误
	- 已用的代码已被使用和测试过，是没有错误的，不用花时间去debug

2. 进行代码复用的方式
	1. 源代码的方式(但有的不提供源码)
	2. 库函数、标准库的方式
	3. 类继承的方式


#### 
1. 类实例化 -> 多个对象，各对象可以通过对象名使用方法区的方法，但是每个对象会维护一份方法吗？？or 每个对象只是知道去哪里使用基类的定义的方法？？
2. 类继承的时候，派生类会继承一份基类的方法吗？ or 只是知道去哪里使用基类的方法？
- 如 virtual的方法推到机制不就是能根据对象来推导对象使用的方法 is 哪一个类中定义的方法，然后使用相应的 类名::方法名()的吗


#### 一些特殊的类

1. const修饰类 -> 类的状态(类中的成员)不能被改变 -> 此时，只有const方法( 不会改变类状态的方法 )可以被使用，别的非const修饰的方法布恩那个被使用
2. static修饰类(想把类当做一个全局共用的功能单元来使用) -> 类中的所有成员都要是static型的 -> 都要在类内声明、类外定义，static函数内只能使用static成员