[toc]

# trivals

## 区分大小写
- ECMAScript中的一切(变量、函数名、操作符)都区分大小写

## 注释方式
1. 单行的
//
2. 多行的
/*
*
*/

## 标识符
- 是什么
	- 就是用于变量、函数、属性、参数等的名字

### 标识符命名规则
- 第一个字符必须是字母、下划线、美元符号开头
- 其他字符可以是字母、下划线、美元符号、数字
- 不能把关键字、保留字、ture、false、null用作标识符

- 注意
	- 标识符中的字母也可以是扩展的ASCII或Unicode字符集中的字符（，），但是不推荐这么做
	- 按照惯例，采用驼峰式命名格式



## 关键字||保留字
### 关键字
- 是什么
- why need it

![ecmascript中的关键字]()
### 保留字
- 是什么
	- 目前没有任何用途，但是将来可能用作关键字，提前进行保护起来
- why need it

![ecmascript中的保留字]()

## op->表达式->语句->函数
### op
- js中的op和C的op根本目的上是一样的(即：模拟出日常生活中对__数字类型__的运算方式，虽然用方法能功能上全覆盖)
	- 唯一的区别是：js因为是弱类型-动态类型-解释性的语言 -> op要对各种类型的实体通用(因为在op获取实体之前是不知道这个是什么类型的)

### 表达式


### 语句

- 推荐风格：
	- 业界普遍推崇始终使用代码块，即使执行的只有一行代码
#### pure语句

#### 流程语句
##### 顺序语句
##### 选择语句
###### 二分支
###### 多分支
##### 循环语句
###### for
###### for-in
###### while
###### do-while

#### with语句

#### 跳转语句
##### return
##### continue
##### break
##### goto



### 函数
- 是什么
	- 是一组被封装的任意多条语句，可以在任何地方、任何时候调用执行(有名的通过函数名来，匿名的通过委托来)
	- 又不仅仅是一组被封装的任意多条语句，还可以有输入和输出
- why need it

- js的函数创建格式
	- ![js的函数创建格式]()

- js的函数的独有特点
	- 因为js是弱类型-动态性 -> 
		- 函数不需要返回类型
		- 输入形参不需要类型
			- 别的语言可能需要提前设计一个函数签名(函数名+输入形参列表(个数+类型))，将来调用必须与该签名一致。-> 方法重载的存在
			- ECMAScript中解析器不会验证命名参数 -> 没有方法重载
	- 理解参数
		- ECMAScript函数不介意传递进来的参数个数和数据类型
			- 即使定义函数时是写的接受两个参数，在实际调用的时候也未必一定要传递两个参数，可以传递0个、一个、两个、...n个
			- 原因是ECMAScript函数中的参数在内部是一个数组来表示的(like，C#中的 params object[] arguments)，函数接收的始终都是这个数组，而不关心数组中包含哪些参数。
			- 在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数(而不是定义函数时的命名参数的个数)
				- arguments对象可以和命名参数一起使用
				- ![]()
				- arguments对象的值和对应命名参数的值永远保持同步
					- 但不是说读取这两个值会访问相同的内存空间，他们的内存空间是独立的，但他们的值会同步
				- ![]()
				- 没有传递值的命名参数会自动被赋予undefined值
					- 但这个命名参数不会和相应的arguments[i]进行同步关联，arguments对象的长度只由传入的参数个数决定，不是由定义是的命名参数的个数决定的
			- arguments对象的存在说明ECMAScript函数：命名的参数只提供便利但不是必须的(即，写函数时一直形参列表为空是可以的)
	- js没有方法重载
		- 定义两个名字相同的函数，则该名字属于后定义的函数(即，调用此名字函数时实际调用的是后面的那个，而不管输入参数匹不匹配)
		- 通过检查传入函数中参数的类型和数量来模拟方法的重载
	- 严格模式对函数的影响
		- 会破坏arguments和命名参数的同步性
			- 对arguments[i]赋值，命名参数并不会变化
#### 匿名函数
- 没法进行回调，只能即时使用：
	- 配合事件-委托的注册方式
#### 有名函数
- why need it
	- 名字用来进行回调


## 严格模式
- 是什么
	- 是为javascript定义的一种不同的解析和执行模型
- why need it
	- 在严格模式下，ECMAScript 3中的一些不确定的行为得到处理，某些不安全的操作将抛出错误
	- to解决变量的冲突问题：
		- var声明的变量is局部的(局部的是指 作用域 is 所在的这个js文件？)
		- js不使用var声明的变量is全局的(同一html上的各js上的同名变量会冲突)
		- 使用strict模式 来 严格限制必须使用var声明变量( == 强行限制为局部变量)，否则报错


- how use it
	- 在整个脚本中启用strict模式
		- 在js代码的第一行写上```''use strict'';```
			- 这行代码是一个编译指示(pragma)，用于高速javascript引擎切换到严格模式来解析js脚本
	- 指定某个函数启用严格模式
		- 在函数体内部的上方写上```''use strict'';```


- 注意
	- 严格模式对变量的影响
		- 不能定义名为eval或arguments的变量，否则会导致语法错误
	- 严格模式对函数的影响
		- 不能把函数命名为eval or arguments
		- 不能把参数命名为eval or arguments
		- 不能出现两个命名参数同名的情况



- 支持严格模式的浏览器
	- IE10+
	- Firefox 4+
	- Safari 5.1+
	- Opera 12+
	- Chrome

## js是什么类型语言
1. js是 __解释型__(逐条解释)+__动态类型语言__(运行期间确定变量类型)+__弱类型语言__(可以不强制类型转换直接赋给变量不同类型的值)
2. __why 这样设计 js??__
### 1. 编译型or解释型or混合型
#### why 要弄成混合型？
1. 每种编译形式都有其存在的原因
2. why java C# 要设置成混合型？优点是什么？跨平台、比解释的快、比编译的跨平台？
#### 混合型
1. JAVA的
### 2. 动态类型语言or静态类型语言
#### 动态类型语言：
- 动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。
- Python和Ruby就是一种典型的动态类型语言，其他的各种脚本语言如VBScript也多少属于动态类型语言。
#### 静态类型语言：
- 静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型。
- C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。
### 3. 强类型定义语言or弱类型定义语言
#### 强类型定义语言
- 强制数据类型定义的语言。也就是说，__一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了__。
- 强类型定义语言是类型安全的语言。
- 举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。
#### 弱类型定义语言
- 数据类型可以被忽略的语言。它与强类型定义语言相反, __一个变量可以赋不同数据类型的值__。
- 强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。
- 另外，“这门语言是不是__动态语言__”与“这门语言__是否类型安全__”之间是__完全没有联系__的！

## 面向对象 or 基于对象

### 面向对象
### 基于对象
- 是什么
- why need it 

### js是基于对象的
- why jaascript要设计成基于对象的而不是设计成面向对象的？？？why 不允许自定义数据类型？？



# 类型系统
- js不能创建新的类型(如不支持自定义类or接口)，只能使用js内置提供的类型

## 按抽性关系划分
## 按存储方式划分
### 基础类型(值类型)
### 引用类型
- 引用类型 != 类的概念
	- 因为类class是面向对象中的概念，是自己根据现实抽象-自定义出来的一个类型，有继承-复合-封装等概念
	- 而js中不允许任何的自定义数据类型，js中的引用类型更像是一组内置的数据类型，我们只能使用他们，不能更改-扩充他们

- 因为js是基于对象的 -> 不存在继承上的关系？？都是平级的？？

#### 引用类型的种类
##### Object
##### Array
- 是什么
	- 是一个数据的有序列表，和python中的list有点像
- why need it

- js中的array类型的特点
	- 每一项可以保存任意类型
		- 如：第一个位置可以保存字符串，第二个保存数值，第三个保存object类型...etc
	- 数组的大小是可以动态调整的
	- 和python中的list有点像

###### 创建Array的方式
1. 使用构造函数
	- 在数组长度上
		- 可以构造时传递长度 <- 如果预先知道数组要保存的项目数量```var color = new Array(20)```
		- 也可以不指定长度```var color = new Array()```
	- 传递的内容上
		- 按零散方式传递```var color = new Array(''red'',''orange'',''yellow'')```
		- 按整个数组方式传递
	- new可以省略
		- 省略new产生的影响是什么？？
2. 使用数组字面量表示法
	- 方括号+逗号分隔
	- ![数组字面量表示法]()
###### 访问数组成员
1. 使用[] + 索引号来访问or修改数组成员的值

- 如果索引号小于数组的length
- 如果索引号大于数组的length
	- 数组会自动增加成员到该索引值加1的长度，新增的成员都是undefined值

###### 数组对象的一些属性
- length
	- 数组的length不是readonly而是可读写的
		- 可以通过设置这个属性 -> 从数组的末尾移除or向数组中添加新项
	- 数组的长度最大可以是4294967295个项，why是这个长度？？有什么说法吗？？

###### 数组对象的一些成员方法
- valueof
- toString()
- toLocaleString()
- join() 

- 数组排序
	- sort()
		- 默认的排序方法
			- 将数组的所有成员中转为string型(通过调用toString()转型方法)，然后对各字符串进行比较，这种排序往往不是我们想要的
				- 如：数值5，10，但进行比较时，"10"会小于"5"
			- sort()方法可以接收一个比较函数作为参数，这个比较函数我们可以自行根据filter规则来设计
	- reverse()
		- 反转数组的成员顺序


- concat()

- slice()

- splice()
	- 用作删除
	- 用作插入
	- 用作替换
	- 此方法无论用作上述三种的那一种，都会返回一个数组，该数组包含从原始数组中删除的项(如果没有删除任何项，则返回一个空数组)，而产生的影响是直接作用在原数组上的和方法返回的不影响


- 查找
	- indexOf()
	- lastIndexOf()
	- 返回值
		- 找到了
			- 返回在数组中的位置索引号
		- 未找到
			- 返回-1


- 迭代方法
	- every()
	- some()
	- filter()
	- map()
	- forEach()

	- 以上方法都不会修改数组中包含的值
	- 每个方法都接受2个参数：
		- 要在每一项上运行的方法
			- 会接受3个参数
				- 数组项的值
				- 该项在数组中的位置
				- 数组对象本身
		- 运行该方法的作用域对象

- 归并方法
	- reduce()
	- reduceRight()
	- 这两个方法都接受2个参数
		- 在每一项上调用的函数
			- 会接受4个参数
				- 前一个值
				- 当前值
				- 项的索引
				- 数组对象
			- 这个函数返回的任何值都会作为第一个参数传给下一项上的函数
			- 第一次迭代发生在数组的第二项上，
				- 因此第一个参数就是数组的第一项，第二个参数即当前值就是数组的第二项
		- 作为归并基础的初始值(可选的)
	- 适合使用归并的情况
		- 求数组中所有值之和

###### 将数组用作栈
- push()
	- 可以接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的length
- pop()
	- 从数组末尾移除最后一项，减少数组的length值，然后返回移除的项

###### 将数组用作队列
- shift()
	- 移除数组中的第一个项并返回该项，同时将数组的长度减1
- push()
- unshift
	- 在数组前端添加任意个项，并返回新数组的长度

##### Date
##### RegExp
##### Function
- 是什么
	- 在js中，函数实际上是对象
		- 每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法
		- 由于函数是对象 -> 函数名实际也是一个指向函数对象的指针 -> 
			- 定义有名方法  几乎== 将一个匿名方法赋给一个变量名 
			- ![]()
				- 除了什么时候可以通过变量访问函数这一点区别
					- 函数声明(具有函数声明提升) != 函数表达式
			- 一个函数对象可以有多个指向它的指针(即，一个函数对象可以有多个名字) 
			- ![]()
- why 这样设计

- 通过函数is对象 -> 为什么函数不允许多态
	- ![]()

- 函数声明 && 函数表达式
	- 函数声明提升
		- 即，函数声明代码可以位于函数调用的代码下方


- 函数可以作为别的函数的输入参数or返回值

- 函数内部属性
	- 在函数内部，有2个特殊的对象：
		- arguments
		- this

- 函数


## 引用类型
### 
#### 引用类型的使用
##### 引用类型创建实例对象
1. 使用构造函数的方法
2. 使用对象字面量表示法
	- ![]()
	- 对象字面量是像函数传递大量可选参数的首选方式

##### 访问对象属性
1. 点表示法
2. 方括号语法
	- 因为有时无法正常使用点表示法，此时使用方括号表示法来访问对象属性
		- 可以通过变量来访问属性
			- ![]()
		- 如果属性名中间存在空格时此时无法使用点表示法
			- ![]()
3. 推荐方式
	- 除非必须使用变量来访问属性，否则我们建议使用点表示法











# 实体系统(内存系统)

- 实体是什么
	- 类型系统和实体的关系是什么？？
	- 实体就是内存中实际存在的东西？？
	- 变量和值的关系？？
	- 值是什么




# js的弱类型-动态性 带来的特点
## 对函数的影响
- js的函数创建格式
	- ![js的函数创建格式]()

- js的函数的特点
	- 因为js是弱类型-动态性 -> 
		- 函数不需要返回类型
		- 输入形参不需要类型

## 对实体声明的影响
### 变量还需要通过类型声明吗？？
### 对象怎么声明呢？？

## 对op运算的影响
