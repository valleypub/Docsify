[toc]


- 按线性||非线性划分	
	- 线性
		- 表结构
			- 串
			- 队列
			- 栈
	- 非线性
		- 树结构
			- 二叉树
				- 完全二叉树(满二叉树是完全二叉树的特殊情况)
					- 堆
				- 二叉查找树
					- 平衡二叉查找树
					- 近似平衡二叉查找树
		- 图结构

- 按实际应用需求
	- 线性表(一对一)
	- 树
	- 图



# 线性表
## 字符串
- 是什么
- why need字符串？？
	
- 因为有这样的需求：
	
- how实际使用字符串
	
- 字符串的实际存储
	
### 字符串匹配
- 根据主串和模式串的数量可以分为：
	- 单模式串匹配
		- 是什么
			- 单模式串匹配算法，是在__一个模式串__和__一个主串__之间进行匹配，也就是说，在一个主串中查找一个模式串。
		- why need it
			- 有些实际任务抽象下来后就是单模式串匹配问题。如：
				- 
	- 多模式串匹配
		- 是什么
			- 多模式串匹配算法，就是在__多个模式串__和__一个主串__之间做匹配，也就是说，在一个主串中查找多个模式串
		- why need it
			- 有些实际任务抽象下来就是多模式串匹配问题。如：
				- 输入系统的敏感词过滤
			- 多模式串匹配问题逐个对每个模式串使用单模式串匹配也能做，但是当模式串个数多时就会变得很低效
#### 单模式串匹配
##### BF(Brute Force-暴力匹配)
##### RK
- 使用hash算法来提升BF	
	
	- 将n-m+1次逐字符字符串对比，换为n-m+1次整数的对比
- 步骤要点
	- 1. 设计hash算法
		- 无hash冲突版
			- 进行变换的方式
			- 缺点：如果串的长度过长，轻易便会超出int的maxValue限制
				- 只有带比较的串的长度很短时才可以
			- 有hahs冲突版
				- 解决方案：如果冲突了，就实打实的逐字符来进行子串模式串的匹配，如果冲突的概率很低-> 匹配的成功率高->逐字符匹配的触发次数少，
	- 2. 计算出待比较的串的hash值
	- 3. 逐个计算n-m+1个字串的hash值并进行比较，并剪纸返回


##### BM

- 坏字符规则的实现比较耗内存，为了节省内存，可以只有好后缀规则没有坏字符原则(只是降低一点速度，因为同时用是是去两者的Max)，但是不能只有坏字符没有好后缀原则。
	- 因为只有坏字符原则，对于坏字符在模式串中没有第二个匹配项时，此时不好确定该移动多少
		- 如果不管青红皂白，一律移动m个(即一个模式串的长度)，由于缺少b->c阶段，容易产生漏检
		- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\algorithm\坏字符规则过度移动.jpg" alt="坏字符的过度移动" style="zoom:25%;" />

- 预计算的三个部分：由模式串唯一确定
	- 坏字符查找表的创建
		- 使用ASCII等编码的方式来创建hash值
			- 受限于字符集的大小
				- < 256 可使用ASCII值来做数组下标
	- suffix的创建
	- prefix的创建

- 使用

##### KMP




#### 多模式串匹配
##### Trie树（字典树）
- 是什么
	- 它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题
	- Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起，如下图所示
		- ![Trie 树的本质](C:\Users\king-kong\Desktop\要做的事情\picture\algorithm\Trie树.webp)
	- Trie 树本质上使用的是 树的特点 or 通过分层-索引-> 次方 -> 对数复杂度的特点？？
		- 我怎么感觉Trie树更像是利用的索引分层？？？？
- why need it


- Trie树的所需操作
	- 插入：将字符串插入Trie树
	- 查找：在Trie树中查找某一字符串

- Trie树适合什么任务||不适合什么任务
	- Trie树适合"输入前缀返回all前缀匹配的字符串"(即：查找前缀匹配的字符串)的任务，Trie树结构就是为此量身定做的
		- 各种应用搜索框内的前缀匹配提示功能(ru:浏览器url栏、淘宝搜索栏、网易云搜索栏)
		- 自动输入补全功能
			- 输入法自动补全功能、
			- IDE 代码编辑器自动补全功能、
			- 浏览器网址输入的自动补全功能
	- Trie树不适合"精确字符串匹配任务"，原因如下：
		- 1. 字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。
		- 2. 要求字符串的前缀重合比较多，不然空间消耗会变大很多。
		- 3. 如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。
		- 4. 我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。
		- 综合这几点，针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树。因为这两种数据结构，我们都不需要自己去实现，直接利用编程语言中提供的现成类库就行了。

###### Trie树的实现（空间换时间版）

1. Trie树如何存储（由所需操作 -> 存储方式）
	- 使用完整数组来存
	- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\algorithm\Trie树的存储方式1.webp" alt="Trie树的实现-空间换时间版" style="zoom:50%;" />

2. 此种Trie树实现版的O(n)复杂度分析
	- 时间复杂度
		- 最好情况：树的深度，对数级
		- 最坏情况：树的分支数 ```*```树的深度，对数级
	- 空间复杂度
		- 每个节点不管三七二十一，均维护一个26个元素的数组，这还只是26个字符的情况，还没有包含小写、大写、中文、数字、各种别的语言
		- 如果各字符串的前缀重合度不高的话，

3. 示例代码实现
```java
public class Trie {
  private TrieNode root = new TrieNode('/'); // 存储无意义字符

  // 往Trie树中插入一个字符串
  public void insert(char[] text) {
    TrieNode p = root;
    for (int i = 0; i < text.length; ++i) {
      int index = text[i] - 'a';
      //判断是否已存在，未存在->插入，已存在->跳过，下一节点
      if (p.children[index] == null) {
        TrieNode newNode = new TrieNode(text[i]);
        p.children[index] = newNode;
      }
      //更新到下一字符节点
      p = p.children[index];
    }
    p.isEndingChar = true;
  }

  // 在Trie树中查找一个字符串
  public boolean find(char[] pattern) {
    TrieNode p = root;
    for (int i = 0; i < pattern.length; ++i) {
      int index = pattern[i] - 'a';
      if (p.children[index] == null) {
        return false; // 不存在pattern
      }
      p = p.children[index];
    }
    if (p.isEndingChar == false) return false; // 不能完全匹配，只是前缀
    else return true; // 找到pattern
  }

  public class TrieNode {
    public char data;
    public TrieNode[] children = new TrieNode[26];
    public boolean isEndingChar = false;
    public TrieNode(char data) {
      this.data = data;
    }
  }
}
```

###### Trie树的实现（牺牲一点时间版）
- 任何使用数组的地方都有可以用链表来代替？？链表用分很多种，根据需要使用链表来做什么(即功能，如：用来查询)来选择合适的链表结构
	- 这里面因为只用作查询，可以选择：跳表、红黑树等来替代数组


###### Trie树的变体
1. 缩点优化
	- 对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并。这样可以节省空间，但却增加了编码难度。

2. DAT（双数组trie树）


###### Trie树相关问题
1. 如果现在给你一个很大的字符串集合，比如包含 1 万条记录，如何通过编程量化分析这组字符串集合是否比较适合用 Trie 树解决呢？也就是如何统计字符串的字符集大小，以及前缀重合的程度呢？
	- 统计字符串的字符集大小
		- 如果假定分布均匀。字符集大小问题 -> 化为 -> 求字符的最小值以及最大值的问题
	- 字符串集合中字符串的统计问题
		- 使用双层循环O(n~2)来统计各字符串出现的次数 -> 使用两次单层循环 + 散列表查找的思想
			- 先遍历一次字符串集合，数组freArray[]存储各字符串的出现次数，初始化freArray[]元素为-1，对于字符串集合中的每个字符串使用hash算法计算hash值，在freArray[hash值]处存此字符串的出现数值，如果是-1，则存为1 ；!= -1,则 freArray[hash值]+1；
			- 第二次遍历字符串集合，通过查找freArray[hash值]输出每个字符串出现的频率
	- 使用Trie树来验证的方式
		- 依次读取每个字符串的字符构建 Trie 树，用散列表来存储每一个节点。每一层树的所有散列表的元素用一个链表串联起来，
		- 求某一长度的前缀重合，在对应树层级上遍历该层链表，求链表长度，除以字符集大小，值越小前缀重合率越高。
		- 遍历所有树层级的链表，存入散列表，最后散列表包含元素的个数，就代表字符集的大小。


##### AC自动机

#### 字符串匹配实际应用
- 单词统一替换功能
- 





### 正则表达式Regex
- 是什么
	- 用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了
- why need it
	- 

https://zhuanlan.zhihu.com/p/83080230




- 正则表达式通用规则，是各种语言通用的吗包括Bashshell,powershell？？？如：

- 正则表达式是怎么实现的？？因为正则表达式本质是更复杂的字符串匹配问题，不同的是实现方式可能效率不同。
- 如何自己实现一个正则表达式？？








# 树
## 二叉查找树
- 是什么
	- 任意节点a满足：左子树all节点的值 < 节点a的值 < 右子树all节点的值
	- 不要求是完全二叉树

- why need it
	- 是二叉树在查找单方面强化的版本

- how实际实现它
	- 怎么存储？
		- 不是完全二叉树 -> 没有那种特性 -> 没法使用数组存储
		- 只能使用指针、引用的方式？？


## 堆
- 是什么
	
	- 完全二叉树 + 层间单向(逐层增大--小顶堆、逐层减小)
- why need it
	- 堆的应用场景
		- 堆排序
			- 1. 建堆
			- 2. 排序
		- 堆排序不如快速排序
			- 1. 堆排序数据访问的方式没有快速排序友好
				- 快排是顺序遍历的、堆排是在数组中跳着来的破坏了cpu的局部性数据缓存原理
			- 2. 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序
				- 快排每一次交换都会讲一个数据排到正确的位置
				- 堆排则每一次取出一个栈顶(最值)后，都要进行建堆，必>=进行一次交换
	- 堆需要的操作
		- 插入元素
			- 1. 将插入的元素放在数组末尾(即，完全二叉树的最后)
			- 2. 进行堆化
		- 删除堆顶元素
			- 1. 将最后一个元素放到堆顶
				- 之所以最后一个元素，是为了删除堆顶后，仍保证是一个完全二叉树
			- 2. 进行堆化
		- 堆化
			- 从上到下的堆化
			- 从下到上的堆化
- how实际实现它
	- 堆如何存储
		- 因为堆是完全二叉树使用数组比较好


- 实际应用
	- 优先级队列
		- 优先级队列是一个抽象的概念
			- 入队和普通队列一样
			- 出队和普通队列不同。不是FIFO，是优先级高的先出队
		- 堆可以看作一个是一个优先级队列
			- 入队放数组最后
			- 根据优先级进行堆化 -> 出队(删除堆顶，再次堆化，找出下一个优先级最高的)
	- TopK
	- 定时器查找

# 图
- 是什么
- why need it

- how实际实现它
	- 如何存储
		- 邻接矩阵
			- 优点：
				- 将图化为一个二位数组(or 一个矩阵)，图的一些问题可以从矩阵的视角来解决
				- 以空间换时间
					- 存储没有破坏cpu的局部性原理
		- 邻接表
			- 优点：
				- 以时间换空间
				- 可以向hash table一样，改进每一个节点对应的那一行线性表，根据需要改为：跳表、红黑树等，来加速搜索


## 流
### 最大流最小割算法




# 其他
## hash table是不是线性表？？
- 线性表的意义来自于从节点间关系的视角来的，线性表是：节点连成一排，每个节点只有前进、后退两个方向(即，只能通过某一结点找到它的上一节点or下一节点)，是节点间关系的抽象

- hash table是专门用于查找的一种特殊的数据结构，它由 数组 + 链表(冲突解决)来构成，他是O(1)查找的一种实现方案，而不是一种通用的节点间关系的抽象。即，我无法知道hash table的一个元素的上一个or下一个元素是什么，只能通过笨遍历的方式；使用hash table的目的是用来 存储、查找的


## 邻接表(图的抽线存储方案)和hash table看起来很像，但是不是一个概念
- 邻接表是节点关系的抽象，而hash table是O(1)查找的解决方案


## 程序中如何选择合适的数据结构
### 从数据特点的视角
- 程序 = 数据 + 对数据的操作。数据结构是为了在程序中表现出数据，算法是优化对数据的操作
	- 根据实际数据的本质特征 -> 选择最合适的ADT ->设计算法


### 从操作需求的视角
- 程序 = 数据 + 对数据的操作。
	- 对数据的操作(功能需求) -> 抽象出逻辑算法 -> 选择合适的ADT -> 确定ADT的实际物理存储方式
	- 如：针对微博用户关系，假设我们需要支持下面这样几个操作：
		- 判断用户 A 是否关注了用户 B；						查找
		- 判断用户 A 是否是用户 B 的粉丝；					查找
		- 用户 A 关注用户 B；						        	插入
		- 用户 A 取消关注用户 B；					    	 删除
		- 根据用户名称的首字母排序，分页获取用户的粉丝列表；	     逐层遍历
		- 根据用户名称的首字母排序，分页获取用户的关注列表。   逐层便利  




## 数据太多在内存放不下怎么办？？
### 哈希算法对数据分片 -> 将数据存在多个机器上
- 每一次查找数据时，比单台的多了一步通过hash查找数据所在机器的操作，因为现在数据不再只位于一台机器而是多台机器上
### 使用数据库存在外部存储上
- 有在内存中使用的数据库吗？


## 深度优先||广度优先才是通用concept
- 深度优先遍历|广度优先遍历 != 深度优先搜索|广度优先搜索，目的不同：一个是遍历，一个是搜索
	- 搜索会有提前返回，但是遍历没有会一直进行到最后
	- 广度优先搜索到的结果是最短路径结果，而深度优先搜索的却不一定是最短路径



## 字符串的千百问
### 为什么只有字符串一种串？？而没有int串、float串、对象串？？
- 因为只有产生字符串的那类问题比较火？？导致只有字符串比较火？？
- 字符串是哪些实际问题的最优解决方案？？
- 因为平时需要用到字符串的地方多？？
	- 各种命名：文件名、目录名、应用程序名、指令名
	- 文件内容：


## 简单是首选
- 在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的KISS（Keep it Simple and Stupid）设计原则。

## 善用预计算concept
- 如果一些任务，1.我们能提前知道他们的全部信息 2. 整个运行过程中不变 -> 就可以对这个任务进行提前计算
	- unity中的光照贴图的预计算
	- 讲一些复杂度较高的问题 -> 缓存 + 查找的问题
		- 26^(m-1) 这部分的计算，我们可以通过查表的方法来提高效率。我们事先计算好 26^0、26^1、26^2……26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。当我们需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。

- BM中预计算 hash table  suffix prefix
- KMP中预计算 next数组

## 任何使用数组(连续使用内存)的地方均能用链表(零散使用)替换？？
- 链表的缺点
	- 一个是对于查找任务不方便，需要遍历；
	- 其次，对于cpu缓存不友好，破坏了数据的来内需型


## 工程上不要将简单的问题复杂化
1. 除非不得已|有极强大的自信，否则不要自己从零开始实现一个XXXXX


## Google大数据处理的三驾马车
- MapReduce
- GFS 
- Bigtable
### MapReduce
MapRedue 的本质就是分治算法