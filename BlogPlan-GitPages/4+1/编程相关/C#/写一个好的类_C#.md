[toc]


# 一个类的一切

![总览图_C#图解教程版]()

## 成员区
- 类由成员构成
- 类中支持的成员种类:
	- 随着C#的版本可能会有变化，查看C#官方文档获取最新的
- 每一种成员的存在都是有意义的，每一种成员要知道下列四点
	- is什么
	- why need is
	- how 创建 它
	- how 使用 它
### 数据相关的
#### 字段
- 可以是任何类型
	- 预定义类型
	- 用户自定义类型
- 和all变量一样，字段用来保存数据
	- 默认是：
		- 可以被写入
		- 可以被读出
	- const修饰
		- 变为常量
		- 只能在声明的同时初始化，后面不能再写，只能读。C#中的const也是在编译期间确定的？
		- const功能上默认等于 const static ，但是不能与static连用
	- readonly修饰
		- 变为只读
		- 声明和初始化可以分开，readonly是在运行期间确定的

- 可以显示|隐式初始化
	- 隐式初始化的值是各类型的空值(编译器内部默认的)
		- int 为 0
		- double 为 0.0
		- bool  false
		- 引用类型 为 null
	- 初始化值必须是编译时可确定的
	- C#的显式初始化机制是怎么实现的？？
#### 常量
- 是什么
	- const修饰的字段
- why need const
- cosnt的底层实现原理
- const实在编译期间确定的？？
	- 编译期间进行替换（like C++中的#define的功能）

#### 常量||静态量
- 常量与静态量相似：
	- 对类的每个实例都是可见的
		- 是实时共享的吗？？
	- 即使没有类的实例也可以使用
- 常量与静态量不同的点：
	- 常量没有自己的存储位置，而是在编译期被编译器替换(like c++中的#define)
	- const 功能上等价于 const static ，但const不能和static同时使用，why???
	- 
##### 本地常量
- 声明在方法内的局部常量
##### 成员常量
- 声明在类内，all成员函数外的常量



### 操作数据相关的
#### 属性
- is什么
	- !=字段(变量)，而是方法成员的一种
	- 与字段不同，属性不会被归类为变量。 因此，不能将属性作为 [ref](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref) 或 [out](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/out-parameter-modifier) 参数传递。
- why need 属性
	- 1. 用来替代，private变量-public方法的访问保护机制 -> private字段-public属性

##### 属性概述
- 属性的形式
```
public class people{

	private int num;
	
	int Num
	{
		set{
			//code here
		}
		get{
			//code here
			return (int) xxx;
		}
	}

}
```

- 属性有类型
- 属性是一个函数成员
	- 不为数据存储分配内存
	- 它像方法一样执行代码来修改字段
- 属性有两个访问器
	- set访问器
	- get访问器
	- 访问器is什么？？
- 属性的这两个访问器，将一个属性看等效于两个轻量级方法的合，专门用于数据的安全输入输出
	- 把属性看作一种有用的读写保护机制
- 属性常和字段关联


##### 属性声明
- 属性有特有的结构
![属性结构]()

- 属性的核心是两个访问器
	- set访问器(写访问器)
		- 拥有一个单独的、隐式的值参，名称为value
			- value与属性的类型相同
			- 可以在set{}块内想普通变量一样使用value，包括对他赋值
	- get访问器(读访问器)
		- 没有参数
		- 拥有一个和属性类型相同的返回类型
			- get{}内必须包含一条return语句，返回一个属性类型的值
- set访问器和get访问器的可以以任何顺序声明
- 除了set,get访问器外不允许有其他任何方法
- 不能显示调用访问器，属性会根据是写入or读出，来隐式调用适当的访问器
- 属性实现（访问器块内{ }）是单个表达式时，可为 get 或 set 使用 expression-bodied 成员，如下：
```
public class Person
{
    public string FirstName
    {
        get => firstName;
        set => firstName = value;
    }
    private string firstName;
    // remaining implementation removed from listing
}
```


###### 访问器(set,get)的访问修饰符
```
	public WebRTC.VideoTrackSource Source { get; private set; } = null;
```

- 默认情况下，属性成员的访问器有和自身相同的访问级别，对索引器也一样
- 也可为两个访问器分配不同的访问级别（不过，每一种访问级别的分配is要有特殊考虑的，不能胡来）
	- 常见的经典搭配：
	- 1. set为private，get为public
		- ```public string name { get; private set; }```
		- 


###### 只读||只写属性
- 属性的两个访问器全声明 -> 读写
- 忽略其中一个访问器的声明(就是只写其中一个访问器，另一个不写) -> 只读 or 只写
	- 只读属性
		- 是一种安全的将数据从类内传出的方法，get块内可以对数据做一些检查、判断等，比直接输出好得多
		- 可以将get访问器看作一种轻量级的安全读出方法
	- 只写属性
		- 是一种安全地将数据从类的外部传入类的方法
		- set块内可以像方法一样对传入的数据做一些判断、检查等一些预处理，这比直接赋值好得多
		- 可以将看作一种轻量级的安全写入方法
- 两个访问器至少有一个必须定义，否则编译器会报错

###### 属性和关联字段 -> 自动实现属性
- 属性常和字段关联
	- 1. private字段 + public属性
		- 一个private字段 配合 一个public属性

- 和属性关联的字段称为后备字段or后备存储


- 属性和后被字段的命名约束
	- 1. 字段camel + 属性pascal
		- ![]()
	- 2. 字段camel+下划线开头  + 属性Pascal
		- ![]()

- 因为属性经常被关联到后被字段，C#提供了__自动实现属性__ -> 来允许只声明属性而不声明后备字段
	- 编译器来为你自动创建隐藏的后被字段
		- 自动实现的属性声明一个private实例支持字段
	- 并自动挂接到get和set访问器上
	- 在 C# 6 和更高版本中，你可以像字段一样初始化自动实现属性：

```
	public string FirstName { get; set; } = "Jane";

	public WebRTC.VideoTrackSource Source { get; private set; } = null;
```

- 自动实现属性的要点
	- 不声明后备字段
		- 自动实现的属性声明一个private实例支持字段
	- 不能提供访问器的方法体，必须被简单地声明为分号
		- get担当简单的内存读
		- set担当简单的写入
	- 除非通过访问器，否则不能通过任何方式访问后备字段
		- 因为不能通过其他的方式访问后备字段，所以设成只读只写没有任何意义，故，必须同时提供读写访问器
			- C#9.0之后，这一项变了：
				- 自动实现属性也可以声明为只读(只有get访问器)
					- 此时，属性除了能在该类型的构造函数中可变(即，可通过set访问器赋值)，在其他任何位置都不可变。
					- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\只读属性的初始化2.PNG" style="zoom:60%;" />
					- 但是，并不影响只读属性仍可以在声明处初始化
					- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\只读属性的初始化.PNG" style="zoom:100%;" />
					- 只读属性的初始化的搭配方式
					- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\只读属性的初始化方式.png" style="zoom:75%;" />

			- 自动实现属性也可以声明为只写()
				- 自动实现属性也可以声明为只读的格式：
					- ``` public string Name {get} = string.empty; ```
					- ``` public string Name => _name```
	- 不能在接口中声明自动实现的属性
		- 如果在接口中声明属性而不定义主体，请使用访问器声明属性，访问器必须由实现该接口的每个类型实现
		- ![接口中的自动实现属性](C:\Users\king-kong\Desktop\要做的事情\picture\C#\接口中的自动实现属性.PNG)
	- 编译器会将自动实现的属性的 get 访问器声明为 readonly，而不管属性声明中是否存在 readonly 修饰符。




```
class Contact
{
    public string Name { get; }
    public string Address { get; private set; }

    public Contact(string contactName, string contactAddress)
    {
        // Both properties are accessible in the constructor.
        Name = contactName;
        Address = contactAddress;
    }

    // Name isn't assignable here. This will generate a compile error.
    //public void ChangeName(string newName) => Name = newName;

    // Address is assignable here.
    public void ChangeAddress(string newAddress) => Address = newAddress
}
```


- 自动属性的优缺点
	- 优点：快速，轻量级
	- 缺点：不能在set,get块内写控制语句，只能实现一些简单的功能


###### 静态属性(like静态方法一样)
- why need 静态属性
- 静态属性和静态成员一样的注意要点
	- 不能访问类的实例成员
	- 不管类是有实例，他们都是存在的
		- 属性也是存在静态存储区，编译时确定的？？
	- 从类的外部访问必须使用类名引用而不是实例名


###### 属性+显示关联 -> 自动实现属性 -> 表达式主体定义实现属性(C#6以后，仅只读属性支持)
- 属性的书写的演进关系
	- ![属性的书写格式的演进关系]()



- 属性+显示关联版：
```

```

- 自动实现属性
	- 有set的话可以声明处直接初始化
	- 只声明 get 访问器（除了能在构造函数中可变(指的是在构造函数中可以使用 = 来给属性set值)，在其他任何位置都不可变）。
		- 但可以在声明处使用 => 来
```
//set,get均含有的
	public string FirstName { get; set; } = "Jane";

//只读的
   public abstract class MediaTrackSource : MonoBehaviour
    {
    	//只读抽象属性
        public abstract MediaKind MediaKind { get; }
		//只读抽象属性
        public abstract bool IsLive { get; }
        
    }
    
    public abstract class VideoTrackSource : MediaTrackSource
    { 
        public WebRTC.VideoTrackSource Source { get; private set; } = null;
        //对只读属性进行表达式主体定义
        public override bool IsLive => Source != null;

        public override MediaKind MediaKind => MediaKind.Video;
    }


```

- 表达式主体定义实现属性(C#6以后，仅只读属性支持)
```
public class Location
{
   private string locationName;

   public Location(string name)
   {
      locationName = name;
   }

   public string Name => locationName;
}
```




##### 属性初始化
- why need it
	- 有时，需要将属性初始化为其类型默认值以外的值。
		- 对于 FirstName 属性的的初始值，你可能更希望设置为空字符串而非 null。 可按如下所示进行指定


###### 属性的默认初始化
- 各种类型的属性存不存在默认初始化？？如果存在那各种默认初始化的值是什么？？


###### 读写属性的初始化(set、get均存在的)
1. 声明处初始化
	- C# 通过在属性的右括号后设置值达到此目的。 
```
public class Person
{
    public string FirstName { get; set; } = string.Empty;

    // remaining implementation removed from listing
}
```
2. 构造函数内初始化
3. 根据set的访问限制付来决定还可以在哪些地方设置值
	- private
	- internal 
	- public 
	- 

###### 只读属性的初始化
1. 声明的同时初始化
	- 使用 = 初始化
	- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\只读属性的初始化.PNG" style="zoom:40%;" />
	- 使用 => 指定从哪读
	- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\只读属性的初始化3.PNG" style="zoom:60%;" />
2. 在构造函数内
	- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\只读属性的初始化2.PNG" style="zoom:40%;" />



4. 只读属性的初始化的搭配方式
	- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\只读属性的初始化方式.png" style="zoom:30%;" />



##### 使用属性
- 不能显示调用访问器，属性会根据是写入or读出，来隐式调用适当的访问器
```
public class people{
	//使用自动属性
	 public int num 
	 {
	 	set;
		get;
	 }
	 
	 num = 5;	//赋值：隐式调用set方法
	 z = num;	//表达式：隐式调用get方法 
}
```

#### 索引器
- 是什么
	- 索引器是一组get和set访问器，与属性类似
- why need 索引器

##### 索引器和属性的异同
- 相同点
	- 和属性一样，索引器不用分配内存来存储
	- 索引器和属性都主要用来访问其他数据成员，他们与这些成员关联，并为他们提供获取和设置访问
		- 属性通常关联单独的数据成员
		- 索引器通常关联多个数据成员
	- 和属性一样，索引器可以只有一个访问器(模拟只读or只写)，也可以两个都有
	- 和属性一样，可以为访问器设置访问限制
		- 默认的都是和所关联的成员的访问限制级一样
		- 可以对访问器进行在设置一级访问限制，但是访问器的访问限制符有一些要求，满足这些要求才可以对访问器进行访问限制
			- get，set访问器均存在是才可以设置
			- 虽然两个必须都存在，但是__只能有一个__访问器有访问限制付。why???
			- 访问器的访问修饰符必须比成员的访问级别有__更严格的限制性__
- 不同点
	- 属性可以声明为static型，索引器不能声明为静态static成员，只能是实例成员
	- 使用的方式不同，属性因为有名字使用的时候以属性名来调用，索引器名为this，使用时以 objName[flag]的方式来调用

##### how 使用 索引器
###### 声明索引器
<img src="C:\Users\king-kong\Desktop\要做的事情\picture\索引器声明.png" alt="索引器的声明" style="zoom:50%;" />

###### 使用索引器
- 因为索引器声明时使用的this作为索引器名，故使用时必须以  objName[index] 这种方式来使用

###### 索引器重载
- 因为所有的索引器的名字是this，一个类又不可能只有一个索引器，故需通过重载来拥有多个索引器
- 索引器的一个bug：
	- 名字一样 + 重载不看返回类型 -> 索引器的重载只能通过参数列表的不同来区分
		- 参数列表的不同在于： 形参的类型 && 形参的个数，而不看形参的变量名（即， [ int dex1 ] 和 [ int index1 ]认为是相同的）
	- 那如果我想重载两个形参个数和形参的类型一样，只有返回类型不同的怎么办？？
		- 书上给出的是改变形参列表中的形参的类型  （ [ int  index ]  [ float index] ）其实还能有[string flag]，所引起的本质只是一个[T flag]配合```switch(flag){case (T)temp1: code; break; case (T)temp2: code; break; }```来使用
		- <img src="C:\Users\king-kong\Desktop\要做的事情\picture\索引器重载.png" style="zoom:50%;" />


###### 索引器的使用示例
```
class Employee{

	public string FirstName;
	public string LastName;
	public string CityOfBirth;
	
	//创建索引器，并与字段进行关联
	public string this[int index]
	{
		set
		{
			switch(index){
				case 0: FirstName = value;break;
				case 1: LastName = value;break;
				case 2: CityOfBirth = value;break;
				default: throw new ArgumentOutOfRangeException("index");
				
			}
		}
		
		get
		{
			switch(index){
				case 0: return FirstName;
				case 1: return LastName;
				case 2: return CityOfBirth;
				default: throw new ArgumentOutOfRangeException("index");
			}
		}
	}

}


//使用索引器
class Program{

	static void Main(){
		
		Employee emp1 = new Employee();
		
		//不通过索引器来get、set字段
		emp1.FirstName = "Doe";
		emp1.LastName = "Jane";
		emp1.CityOfBirth = "Dallas";
		
		Console.WriteLine("{0}",emp1[0]);
		Console.WriteLine($"{emp1.FirstName} ");
		
		//通过索引器的方式来
		emp1[0] = "Doe";
		emp1[1] = "Jane";
		emp1[2] = "Dallas";
		
		Console.WriteLine("{0}",emp1[0]);
		Console.WriteLine($"{emp1[0]} ");
	
	}


}



```
##### 索引器的本质
- this[ T flag] 配合 switch case等来使用，flag只起到情况标志的作用，故可以为任意类型：如：int index  string flag
```

```



##### 该不该使用索引器？？
- 索引器本质上就是统一的处理一组同类型的成员，这组成员只用index来区分，那，为何不直接讲这些成员直接声明为一组同类型的array？？使用索引器岂不是会增加模糊性？？




#### op
- 是什么

- why need op运算符
	- 仅仅是为了适配人们的多年的现实生活中的使用习惯，op完全可以由成员方法来替代（实际上op就是通过成员方法来实现的？？）


#### 方法区
- 方法is具有名称的代码块，方法名用于回调使用
- 
##### 构造方法
- C#支持字段声明处初始化（而不是在构造方法内初始化），但是类声明时只是创建了个模板，并未分配内存，此时的初始化（往特定地址内存处填值）是怎么实现的？？
```
public class people{
	public const string name = "kanghaiquan";

}
```

###### 默认构造

###### 实例构造

###### 静态构造
- 是什么
	- static修饰的构造方法
- why need 静态构造函数
	- 实例构造方法用于初始化每个类的新实例
	- static构造方法用于初始化类的静态字段
		- 静态字段只能在静态构造函数中进行初始化
	- 故，一个类可以同时有实力构造和静态构造
- how 使用 static构造函数。（应该和实例构造方法不同，在实力构造方法之前使用？？？）
	- 不能从程序中显式调用静态构造函数，系统会自动调用他们，在：
		- 类的任何实例被创建之前
		- 类的任何静态成员被引用之前
		- 但是，具体的时刻无法确定是系统自己决定的？？


- 静态构造方法||实例构造方法：
	- 相似点：
		- 名称必须与类名相同
		- 不能有返回值
	- 不同点：
		- 静态构造方法不能有参数
		- 静态构造方法不能有访问修饰符
		- 静态构造方法只能有一个，不能重载。(why不支持重载？？ 因为 无返回值|无修饰符|不能带参数 + 名字又都一样 -> 不满足重载的条件)
		- 和普通静态方法一样，不能访问类的实例成员
		- 不能显示调用（实例构造方法声明成public后可以显式调用）



##### 析构方法
- 是什么
	- 用来清理非托管资源
- why need 析构
	- 对于托管资源(dotnet的类、) -> GC -> 不用写析构方法
	- 但是非托管代码（）中的类，需要自己写一个析构函数来清理自己

##### 普通方法

##### 方法的构成

![方法的结构]()

- 返回类型
- 方法名
- 输入参数列表
- 代码块
##### 参数
![方法的参数]()






#### 事件


## 成员级的特点
### const(常量||变量）
- 是什么
- why need const

- cosnt的底层实现原理

- const实在编译期间确定的？？
	- 编译期间进行替换（like C++中的#define的功能）

- const能修饰的成员
	- 字段
	- 方法？？

- 常量与静态量相似：
	- 对类的每个实例都是可见的
		- 是实时共享的吗？？
	- 即使没有类的实例也可以使用
- 常量与静态量不同的点：
	- 常量没有自己的存储位置，而是在编译期被编译器替换(like c++中的#define)
	- const 功能上等价于 const static ，但const不能和static同时使用，why???
	- 
##### 本地常量
- 声明在方法内的局部常量
##### 成员常量
- 声明在类内，all成员函数外的常量
##### 本地常量&&成员常量的区别
- 


### static(备份(实例成员)or实时共享(静态成员))
- is什么
- why need it
	- 有时多个实例和类需要一些实时同步(同一备份)的情况
- static成员底层是怎么实现的？
- 可以为static修饰的成员
	- 除了 常量(const)和索引器
		- const和static不能连用
			- why？？什么原因导致的
		- why索引器不可以？
- C#的static成员不用像C++那样在类的外部的上方提前声明？？
- static成员存储的位置和类的实例不同，它其实不算类or类的实例的成员 -> C++和C#对他的特殊处理
	- 因为一直是把静态成员当作独立于所有类和类的实例之外的一块共享内存
	- ![静态成员的存储区域]()
- static在继承上的影响
- 静态成员的生存期
	- 实例成员只有在类实例化实例后才存在，实例销魂后实例成员也不存在(运行期间操作的)
	- 静态成员在类声明后就可使用，因为类不会被回收(只有实实例会被回收)->整个运行期间静态成员一直存在？(编译期间操作的)
- static成员声明时就会分配内存？？别的普通字段只有初始化时才会分配内存？
	- 实例成员(非static)
		- 只有在实例创建后才产生实例成员，实例销毁后实例成员也就不存在了
#### 实例成员
- 默认情况下，成员被关联到一个实例
#### 静态成员
##### 静态字段
- 静态字段被所有实例共享，所有实例访问同一内存位置。
	- static是分配到静态存储区？？
	- 编译期间确定(编译期间分配内存)？？
- 如果静态字段有初始化语句，那么会在使用该类的任何静态成员之前初始化该字段，但没必要在程序执行的开始就初始化
##### 静态方法
- 没有类的实例，任然可以调用静态类的方法
- 静态函数成员不能访问实例成员，只能访问别的静态成员(字段or方法)。实例方法可以访问任何静太成员
	- 因为调用静态成员函数的时候可能类还没有实例化，这个时候实例成员是不存在的

###### 静态属性(属性is方法成员的一种)

### readonly
- why need readonly
	- 弥补了const的不足(已经有了const 为什么还需要readonly? )
		- const只能在字段的声明语句处进行初始化，而readonly字段可以在下列2个位置设置他的值(这说明readonly和const的背后实现原理不同？？)
			- 初始化的位置变多了：
				- 所在类的构造函数中(不可在同一类的构造方法之外的方法中对readonly成员赋值)
					- 如果想限制的是static字段，初始化必须在静态构造函数中
				- 字段的声明处(此时类似const)
			- 可以多次赋值(那这还叫readonly吗？？？)
				- 可以在字段声明和构造函数中多次分配和重新分配只读字段
		- static不能和const连用 -> static成员可以和readonly连用 
			- 任意const成员is static成员(const == const static)，但static成员不能声明为const型
		- const字段的值只能在编译时决定(编译器进行替换，like #define)，而readonly字段的值可以在运行时决定
			- 相当于一个是静态的(一旦开始运行，整个运行期间不能改变)，一个是动态的（在运行期间才进行指定的，一旦指定后才变为无法改变的常量）
				- 这种增加的自由度，可以允许你在同一个类的不同构造函数中设置不同的值 -> 同一类的不同实例中的同一readonly成员的值可以不同
				- 也可以使用运行时才能确定的变量来对readonly成员赋初值，而给const成员赋初值必须使用编译期就能确定的量
					- 如：```public static readonly uint timeStamp = (uint)DateTime.Now.Ticks; ```
				- 而，const因为编译期间就确定了 -> 所有类的实例的const成员的值是相同的
		- const的行为总是静态的（这个静态的含义是：1. 总是all实例共享的，2. 全局的（即，整个运行期间都有效，且不可更改）），而readonly:
			- 可以是实例字段，也可以修饰static字段
			- 他在内存中有存储位置
	- readonly有自己的用法：
		- 对值类型和引用类型的不同
			- readonly修饰值类型成员
				- 由于值类型直接包含数据，因此属于 readonly 值类型的字段不可变
					- readonly应用于值类型 == c++的 const int a = 5;
			- readonly修饰引用类型成员 
				- 由于引用类型包含对其数据的引用，因此属于 readonly 引用类型的字段必须始终引用同一对象(不能再引用别的对象)，但这个对象本身是可变的。
					- readonly应用于引用类型 == c++的常指针const T* p != T* const p，只是指向不变而不是指向的内容不能变，即readonly 修饰符可防止字段替换为引用类型的其他实例。 但是，修饰符不会阻止通过只读字段修改字段的实例数据。 




#### readonly struct
#### readonly ref
#### readonly 结构成员





### 成员访问限制符
- 类的成员默认访问限制符为private
	- 别的类型(struct enum interface )的成员的默认访问类型is什么？？
- 成员访问限制符限制的是外部的类对类内成员的访问，并不限制类内的成员的互访 -> 不管成员是什么限制付类内的成员都可以相互访问
- 成员不能比它的类有更高的可访问性
	- 即，如果类的可访问性是internal（程序集内），那类内的成员也不能从程序集的外部看到(无论成员的访问修饰符是什么，public也不例外)
#### private
```
	本类的成员 && friend(friend和孩子 没有关系)
	换位思考，确实有些秘密是 朋友知道 而 孩子不知道的，朋友才是除了我们自身知道我们秘密最多的人，可以将孩子变成friend(设置friend)，那样孩子也可以知道我们的秘密了(就像个老朋友一样)
	Q:为什么孩子继承了父亲的一切，但是子类的成员却没法访问父亲的private成员??
	A:就像是你从父亲手里继承了一个宝箱，但是这个宝箱上了密码，只有他自己(他自己是由他的全身(即父类的all成员构成))and他的friend知道密码，可以打开，而孩子只是拥有却不能打开
	Q:为什么说子类继承父类is拥有父类的一切呢？？
	A:因为子类会先开辟一个空间，这个空间和父类类型一样大，刚好用来存储父类，且这个空间位于他新增的成员之前
```

- 能被他自己的类的成员，不能被其他的类(包括派生的类)
- private成员也能被嵌套在他的类中的类成员(嵌套类)访问

#### protected
本类的成员 && 继承关系的亲子(即使是在程序集外部继承的)

#### public
所有的类，包括程序集内的类和程序集外部的类都可以访问。前提是不违反__成员不能比它的类有更高的可访问性__这个大前提
#### internal
- 对同一程序集内部的所有类可见，对程序及外部的任何类不可见
	- 如：同一namespace下的各类能相互访问

#### protected internal
- 对继承该类的类||同一程序集下的所有类
	- 如：在同一namespace || 具有亲子关系的类
	- 是protected于internal的并集而不是交集

### 成员修饰符的顺序

![成员修饰符的顺序]()

[特性]  [修饰符]  [核心声明]

- 特性
	- 如果有特性必须放在修饰符和核心声明之前(不同块之间严格按顺序)
	- 如果有多个特性，它们可以是任意的(同一块之间是任意的)
- 修饰符
	- 如果有修饰符，必须放在核心声明之前(不同块之间严格按顺序)
	- 如果有多个修饰符，他们之间是可以任意的(同一块之间是任意的)
- 字段的和方法的这三部分之间是有细微区别的
	- ru: C#中不支持const方法？？(c++中是支持的)


### this关键字
- 是什么
- why need this关键字
	- 类中使用成员名即可进行成员间的互相访问，为什么还需要一个thi关键字？？


### 抽象成员(abstract)
- 是什么
	- 抽象成员是被设计为被重写的函数成员(必须在派生类中被重写实现)
		- 必须是一个函数成员。字段和常量不能声明为抽象成员
			- 只有4种函数成员可以声明为抽象的
				- 方法
				- 属性
				- 索引器
				- 事件
		- 不能有具体的实现代码块，只能有方法的声明 ![]()
		- 只可以在抽象类(abstract修饰的类)中声明，声明时必须也是用abstract修饰符
		- abstract不可以和virtual连用，但必须配套override来使用
- why need 抽象成员
	- 



### 虚成员(virtual-override)
- is什么
- why need 虚成员
	- 有时需要从基类作为入口访问子类的中的oveeride的方法
		- 如：俄罗斯方块问题


- 使用virtual-override的注意事项
	- 不能覆写static方法or非virtual修饰的方法
	- 覆写和被覆写的方法需要具有相同的可访问性



## 类级别的特点
### 类访问限制符
- 类的可访问性有两个级别：
	- public
		- 标记为public的类可以被__任何的程序集__中的代码访问
	- internal
		- 只能被此类所在的程序集内的类访问
- 类默认的访问级别是internal
	- struct enum interface有没有访问限制付？？有的话默认是什么？？
#### public
- 标记为public的类可以被__任何的程序集__中的代码访问
#### internal
- 只能被此类所在的程序集内的类访问(zhu:程序集既不是exe也不是dll)
- 这是类默认的访问级别
### 分布类--partial
- 在多个地方同时定义一个类的需求
- 如何解决资源(成员)冲突&&保护的？？ru:双方同时定义了同名属性or(方法名&&标签(输入参数列表)都一样的)这种原本单类中不允许的操作是怎么解决的？？
- 


### 静态类--static

- 是什么
	- 因为不能被实例化来使用，故模拟的实际是一个能公用的方法&&信息集合
		- 如：Marshal
- why need 静态类
	- 有时我们会需要all(此类&&此类实例的对象)__实时共享一些信息or功能__、__在类实例化前就能在别处使用__的需求 -> 静态成员的由来


- 静态类的特点
	- 因为只能全局存在一个备份-> 不能被继承&&不能被实例化(因为这两个操作均会创建备份)
		- 即，不能使用 new 关键字创建静态类的实例；
	- 静态类的成员全是static型的(因为only static性的才可以不被实例化就能使用、才有意义)
		- 静态类中的可以拥有的静态成员有哪些：
			- 静态构造函数
				- 静态构造函数可以用于静态类，也可用于非静态类；
				- 静态构造函数无访问修饰符、无参数，只有一个 static 标志；
				- 静态构造函数不可被直接调用，当创建类实例或引用任何静态成员之前，静态构造函数被自动执行，并且只执行一次。
			- 静态字段
				- C3字段可以进行类内初始化，也可以使用构造函数
			- 静态方法
			- 静态属性？？
	- 因为是only一份,又因为要被别的类common访问--> 全局的&&一旦class创建完成便可以使用&&必须通过  类名.成员名 来使用(因为不能被实例化)
		- != 普通类中的static成员，普通类的static成员也是 only一份备份&&一旦class创建完便可以use&&可以 类名.成员名 也可以 对象名.成员名lai use(这一点不同)
- 1. 静态类存在的目的是：一些只能存在一份的、被公共use的(属性、方法)的封装

- 一个例子
```

public static class ClassA  
{  
	//类内初始化
    public static string AppName = "hello, this is a static class test";  
    public static int num = 5;  
    //静态构造函数初始化
    static ClassA()  
    {  
        num = 15;  
    }  
  	
    public static int getNum()  
    {  
        return num;  
    }  
}  



```



### 抽象类--abstract
- 是什么
	- 设计为只能被继承使用(不能被实例化)的类
	- 模拟的是一个抽象入口，没法独立使用，但是作为一个对多个子类的统一管理的入口来方便开发
- why need 抽象类
	- 确实all抽象类都可以强行使用具体类来代替，但是有时实在没必要(使用抽象类能更高效)
		- 其实不是说抽象类有什么用，一般类确实也能满足应用，但是现实中确实有些父类中的方法确实没有必要写，因为各个子类中的这个方法肯定会有不同，所以没有必要再父类里写。当然你也可以把抽象类都写成非抽象类，但是这样没有必要。
			- 可以使用具体类 + 覆写机制 来完全代替 抽象类，但有些情况实在没有必要强行实现基类中的一些方法（因为这些方法一定会在子类中覆写成各不相同的，使用的时候也只会通过抽象父类+多态性来调用具体派生类中的那个方法）
	- 有个提示作用
		- 而写成抽象类，这样别人看到你的代码，或你看到别人的代码，你就会注意抽象方法，而知道这个方法是在子类中实现的，所以，有个提示作用。
	- 俄罗斯方块为例来说明 抽象类对于某些开发是有用的
		- 问你个问题，你知道什么是“东西”吗？什么是“物体”吗？ “麻烦你，小王。帮我把那个东西拿过来好吗” 在生活中，你肯定用过这个词－－东西。 小王：“你要让我帮你拿那个水杯吗？” 你要的是水杯类的对象。而东西是水杯的父类。通常东西类没有实例对象，但我们有时需要东西的引用指向它的子类实例。 你看你的房间乱成什么样子了，以后不要把东西乱放了，知道么？ 又是东西，它是一个数组。而数组中的元素都是其子类的实例。
		-  --------- 上面讲的只是子类和父类。而没有说明抽象类的作用。
		- 抽象类是据有一个或多个抽象方法的类，必须声明为抽象类。抽象类的特点是，不能创建实例。 这些该死的抽象类，也不知道它有什么屁用。我非要把它改一改不可。把抽象类中的抽象方法都改为空实现。也就是给抽象方法加上一个方法体，不过这个方法体是空的。这回抽象类就没有抽象方法了。它就可以不在抽象了。 当你这么尝试之后，你发现，原来的代码没有任何变化。大家都还是和原来一样，工作的很好。你这回可能更加相信，抽象类根本就没有什么用。
		- 但总是不死心，它应该有点用吧，不然创造Java的这伙传说中的天才不成了傻子了吗？ 接下来，我们来写一个小游戏。俄罗斯方块！
		- 我们来分析一下它需要什么类？我知道它要在一个矩形的房子里完成。这个房子的上面出现一个方块，慢慢的下落，当它接触到地面或是其它方块的尸体时，它就停止下落了。然后房子的上面又会出现一个新的方块，与前一个方块一样，也会慢慢的下落。在它还没有死亡之前，我可以尽量的移动和翻转它。这样可以使它起到落地时起到一定的作用，如果好的话，还可以减下少几行呢。这看起来好象人生一样，它在为后来人努力着。当然，我们不是真的要写一个游戏。所以我们简化它。我抽象出两个必须的类，一个是那个房间，或者就它地图也行。另一个是方块。我发现方块有很多种，数一下，共6种。它们都是四个小矩形构成的。但是它们还有很多不同，例如：它们的翻转方法不同。先把这个问题放到一边去，我们回到房子这个类中。房子上面总是有方块落下来，房子应该有个属性是方块。当一个方块死掉后，再创建一个方块，让它出现在房子的上面。当玩家要翻转方法时，它翻转的到底是哪个方块呢？当然，房子中只有一个方块可以被翻转，就是当前方块。它是房子的一个属性。那这个属性到底是什么类型的呢？方块有很多不同啊，一共有6种之多，我需要写六个类。一个属性不可能有六种类型吧。当然一个属性只能有一种类型。我们写一个方块类，用它来派生出6个子类。而房子类的当前方块属性的类型是方块类型。它可以指向任何子类。但是，当我调用当前方块的翻转方法时，它的子类都有吗？如果你把翻转方法写到方块类中，它的子类自然也就有了。可以这六种子类的翻转方法是不同的。我们知道'田'方块，它只有一种状态，无论你怎么翻转它。而长条的方块有两种状态。一种是‘－’，另一种是‘｜’。这可怎么办呢？我们知道Java的多态性，你可以让子类来重写父类的方法。也就是说，在父类中定义这个方法，子类在重写这个方法。那么在父类的这个翻转方法中，我写一些什么代码呢？让它有几种状态呢？因为我们不可能实例化一个方块类的实例，所以它的翻转方法中的代码并不重要。而子类必须去重写它。那么你可以在父类的翻转方法中不写任何代码，也就是空方法。我们发现，方法类不可能有实例，它的翻转方法的内容可以是任何的代码。而子类必须重写父类的翻转方法。这时，你可以把方块类写成抽象类，而它的抽象方法就是翻转方法。当然，你也可以把方块类写为非抽象的，也可以在方块类的翻转方法中写上几千行的代码。但这样好吗？难道你是微软派来的，非要说Java中的很多东西都是没有用的吗？当我看到方块类是抽象的，我会很关心它的抽象方法。我知道它的子类一定会重写它，而且，我会去找到抽象类的引用。它一定会有多态性的体现。但是，如果你没有这样做，我会认为可能会在某个地方，你会实例化一个方块类的实例，但我找了所有的地方都没有找到。最后我会大骂你一句，你是来欺骗我的吗，你这个白痴。把那些和“东西”差不多的类写成抽象的。而水杯一样的类就可以不是抽象的了。当然水杯也有几千块钱一个的和几块钱一个的。水杯也有子类，例如，我用的水杯都很高档，大多都是一次性的纸水杯。记住一点，面向对象不是来自于Java，面向对象就在你的生活中。而Java的面向对象是方便你解决复杂的问题。这不是说面向对象很简单，虽然面向对象很复杂，但Java知道，你很了解面向对象，因为它就在你身边。



- 抽象类的特点
	- 抽象类中可以有抽象成员||非抽象成员
	- 抽象类可以派生抽象类||普通类
		- 如果抽象类派生出具体类(具体类)
			- 派生类必须使用override关键字实现抽象基类all抽象成员
			- 只要有一个抽象成员未被具体实现，那派生类也要声明为abstract型，因为abstract成员只能出现在abstract类中声明
		- 如果派生类派生的仍是abstrct类
			- 派生类可以不使用override对抽象基类的抽象成员进行实现


### 嵌套类--封闭类


### sealed密封类
- 是什么
	- 和abstract基类正好相反，只能被独立实例化使用，不能被继承使用
- why need 密封类






# 类间关系


## 继承链的两个关键字
### base关键字
### this关键字




# 一个类的完整一生(总历程-运行时)
## 声明类
- 类的声明只定义类的特征和成员，并不创建类的实例，只是创建用于创建类实例(对象)的模板
	- 类声明不会分配内存？？const成员 static成员是例外？
## 创建类的实例
### 对象创建表达式
- new TypeName ()
- new运算符为任意类型的实例分配并初始化内存，它依据类型的不同从栈or堆里分配
	- 任意类型均可使用new来分配？int double
	- public int a = 5; 和 public int a = new int (5);的区别是什么
	- C++中的new是分配到动态存储区(heap)，C#的new的分配到栈or堆视类型而变。什么类型分配到栈上，什么类型分配到堆上？？
		- 引用类型is分配到堆上？？
- 对象创建表达式如果是给引用类型分配内存，表达式返回值返回一个引用，指向堆中分配的实例
	- 对象创建表达式用于值类型返回什么？
### C#允不允许不使用new，创建局部的对象(自由存储区的)？像C++那样
##  使用类or类的实例(对象)
- 从类的内部访问成员
	- 直接使用成员名即可
- 从类的外部访问成员
	- 对于静态成员：
		- 只能使用 ClassName.成员名的方式
	- 实例成员
		- 只能使用 objNmae.成员名的方式

- C#程序由一个主类(含有入口函数Main(){}的类)+多个辅助类构成
	- 如果多个类中写有入口函数会怎样
# C#的类风格指南
## effective C# 50
## Microsoft推荐

## 从实践中总结出来的类的书写模式
1. 多用属性
2. 




# 疑惑

## 属性||索引器||枚举器||迭代器的辨析
- 既然索引器是对类中同类型的成员进行分簇，为什么不直接使用成员数组呢？使用索引器的好处究竟是什么


## 抽象成员(abstract) ||虚成员(virtual) 的辨析
### 使用目标不同
- 虚成员是为了
- 抽象成员是为了
- 
### 抽象成员&&虚成员的区别
![]()


## 按生存周期来考虑
- static成员 > 实例成员 > 被嵌套的局部成员 , 因为C#不允许裸的，整个程序中只有这三种生命周期？？
![]()


## 基类作为子类的入口带来了好多问题

### 带来了 virtual和override

### 带来了 abstract和override

### 带来了 可见性(截断)
- 从基类中只能看到子类继承的父类的区吧，子类中的新增区，实现的接口可以从基类被访问？？
	- why 子类实现的接口可以被访问？？![]()

```
class base{
	public int a = 5;

}

class derive : base{
	public int b = 6;

}

class program{

	public static void Main(){
	
		base Base = new derive();//对象一经创建是不可变的，那是不是从创建的derive对象新建了一个Base类型的对象？？通过复制构造函数？？是不是经过这个过程导致基类变量引用子类对象是不可见新增区等基类没有的部分的？？
		
		int i = Base.b; //这个符合吗？？


	}

}

```