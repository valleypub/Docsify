[toc]


# 网络通信模型及分类
## 分散式||集中式||分布式系统
### 分散式

- 是什么
- why need it
	- 优点
		
	- 缺点
		1. 容易导致共享的不同用户之间的数据不一致性。
		2. 数据冗余。

### 集中式
- 是什么
	通过一台主计算机保存共享的全部数据

- why need it
	- 优点
		1. 减少了数据冗余
		2. 减少了共享数据的不一致性
	- 缺点
		1. 可靠性不行


### 分布式 = 分散式 + 集中式

- 是什么
	1. 资源透明提供给用户。
		用户在使用资源时不需要知道资源是本地的or远程的，对于远程资源也可向本地资源一样任意调用，但，计算机网络需要先知道资源的位置，与资源所在的主机建立连接后才能使用。
	2. 高度内聚性。

## C/S B/S P2P网络通信架构
C/S B/S是在分散式系统、集中式系统、分布式系统基础上发展出来的。
### C/S

![]()

- 是什么
	- 客户端:
		主要负责界面和处理业务逻辑，并为用户提供网络请求服务的接口，如：数据查询请求。
	- 服务器端：
		一般以数据处理能力较强的DBMS作为后台，负责接受和处理用户对服务的的请求，并将这些服务__透明的__提供给用户。
		透明的意思是：

- 优缺点
	- 优点：
		1. 技术成熟
		2. 响应速度快
		3. 可以充分利用两端的硬件环境的优势，将任务合理分配到客户端和服务器端来实现。
	- 缺点：
		1. 针对性开发，不能灵活变更，维护和管理难度大，不利于扩展。

- CS架构一般采用__两层结构__

- 可以使用多种协议来进行网络传输，如：
	- http
	- ftp
	- 


### B/S

- 是什么
	- 只需维护一个服务器，客户端由专门开发的程序转换为浏览器。B/S是随着Internet的兴起，对C/S的改进和优化。
	- 和C/S无本质区别，是C/S的一种特例。特殊在这个模型必须使用HTTP。
- 优缺点
	- 优点：
		1. 分布性强
		2. 共享性强
			- 一台计算机可以访问任意一个Web服务器，用户只需要知道服务器的网址即可。
		3. 开发简单
			- 不需要提供专门的客户端软件。服务器端软件也按照统一的http协议来编写
		4. 维护方便
		5. 可扩展性、高灵活
	- 缺点：
		1. 数据安全性
			- 解决方案：
				- https


- B/S采用的是__三层结构。
	- __在数据管理层(server)、用户界面层(Client、浏览器)之间加了一层，称为中间价(Middleware)。
	- 三层架构是伴随着中间件技术的成熟而兴起的，核心概念是：利用中间件将应用分别表示为界面层、业务逻辑层、数据存储层3个不同的处理层。
	- 中间价作为构造三层结构的基础平台，具有如下主要功能：
		1. 负责客户机与服务器之间的连接和通信
		2. 负责服务器和数据库之间的连接和通信
		3. 实现应用与数据库之间的高效连接。
		4. 具有中间价的三层结构在层与层之间相互独立，任一层的改变不会影响到其他层的功能。
		![三层结构]()


### P2P

- 是什么

- 优缺点
	- 优点：
	- 缺点：

# 网络程序通信机制
## 端口与套接字
### 端口
#### 物理端口
RJ45端口

SC端口


#### 逻辑端口(进程标识)

http--80端口

ftp--21端口

smtp -- 25端口



- 端口号的分配规则:
|端口号|功能|
|----|----|
|0|不使用，或作为特殊的使用|
|1~255|保留给特定服务|
|256~1023|保留给其他服务|
|1024~4999|可以用作任意客户的端口|
|5000~65535|可以用作用户的服务器端口|

### 套接字

- 是什么
	套接字是支持TCP/IP网络通信的基本操作单元，是不同主机间的进程进行双向通信的端点，使用套接字便于区分不同应用程序进程间的网络通信和连接。如图1-4所示，有三台建立了通信连接的主机。
	对通信的一对主机来说，套接字包括发送方IP、发送方端口号、接收方IP、接收方端口号、协议五部分。

- why neet 套接字
	- 套接字屏蔽了TCP/IP协议栈的复杂性，使得在网络编程者看来，两个网络进程间的通信实质上就是他们各自所绑定的套接字间的通信。即，套接字就是抽象出来的一层，用来帮助我们高效简单的使用TCP/IP协议栈。

- 套接字抽象层的工作步骤流程：
	![]()

## 基于套接字的网络进程通信机制



# C#网络开发基本类

## DNS类
- 是一个静态类



### 实战案例
1. 显示本机的IP地址、主机名等信息
![]()


## Ping相关类
### Ping类

### PingOptions类


### PingReply类


### 实战案例
1. 使用Ping PingReply PingOptions来检测目标主机是否可达
![]()


## Socket相关类

### 套接字和Socket类的关系
- 套接字是什么
	一个套接字既保存了__本机的IP地址和端口__，也保存了__对方主机的IP地址和端口__，同时还有__双方通信的协议信息__。

- Socket类是什么
	- Socket类是套接字的代码实现，套接字是一种抽象概念，需要借助来Socket类来实际实现
		- System.Net.Sockets命名空间提供了Socket类

- Socket通信模型
![]()


### 套接字类型和使用Socket实现
__套接字有三种类型：__
1. 流套接字
	- 用来实现TCP通信。提供了：__面向连接的__、__可靠的__、__数据无错的__、__无重复的__、__保证顺序的(收发的数据顺序相同)__数据传输服务。
2. 数据报套接字
	- 用来实现UDP通信，以独立的数据报形式发送数据。提供了：面向无连接的、不可靠的、可能有错的(直接接收端丢弃？)、可能重复的(直接丢不会重复？)、不保证顺序的(数据分片后到达时序不同？)
	- 优缺点：
		- 优点：
			1. 由于不需要建立连接，也不需要确认，所以传输速度更快。
			2. UDP有消息边界。UDP把上层应用程序交下来的报文添加首部后直接交给IP层，既不拆分，也不合并，这样就保留了这些报文的边界。所以在使用UDP时，无须考虑边界问题，因此UDP在使用上比TCP简单。__这些边界有啥用？？？__
			3. UDP可以一对多传输。由于UDP传输数据不需要建立连接，也不需要维持连接状态，所以一台服务器可以向多个客户机同时传递相同的消息。__利用UDP的广播和组播功能可以同时向网上的所有客户发送消息，这一点也比TCP方便。__
		- 缺点：


3. 原始套接字
	- 原始套接字用来实现IP数据包通信，用于直接访问协议的较低层，常用于侦听及分析数据包，广泛应用于高级网络编程，也是一种经常使用的黑客手段。



__套接字类型需要使用Socket来实际实现：__
1. Socket构造函数：
	- public Socket(__AddressFamily__ addressFamily, __SocketType__ socketType, __ProtocolType__ protocolType);
2. 各参数含义：
	- __addressFamily__：指网络类型，使用AddressFamily枚举指定Socket使用的寻址方案，常见的有：
		- AddressFamily.InterNetwork（表示IPv4的地址）
		- AddressFamily.InterNetmorkV6（表示IPv6的地址）。
	- __socketType__和__protocolType__：这两个枚举类型的参数必须对应，共同指明Socket使用哪种协议的哪种套接字。表2-5列出这两个参数的组合。
		<img src="C:\Users\king-kong\Desktop\要做的事情\picture\C#\C#网络编程\配套的.PNG" style="zoom:50%;" />	
3. 常用搭配：
	- 流套接字：
		- Socket socket=new 	Socket(AddressFamily.InterNetwork,SocketType.stream,ProtocolType.Tcp) 



### Socket类的介绍：
1. Socket类的__常用属性__
![](C:\Users\king-kong\Desktop\要做的事情\picture\C#\C#网络编程\Socket类的属性.PNG)
2. Socket类的__常用方法__
	- Bind()
		- 用于Socket与本地IP地址和端口号关联。
		- 一般客户端的都会自动选择一个ip + port，但是serer端需要手动指定ip + port。这样是有原因的。因为客户端(使用Connect())接入server时需要使用server端的ip+port，故我们需要在server端自己选择一组ip+port来使用并记录下来给client来接入server;而client却不需要知道自己本机构建socket使用的ip+port，因为在client接入server时，底层会自动地将client使用的ip+port告知server端（server端的accept()的返回值中会包含客户端的socket信息），来实现双方的连接建立。client是怎么告知server的？？？？
	- Listen()
		- 用于等待客户端发出连接请求，其中的backlog为用户的__最大连接数__，超过该参数值的其他客户不能与服务器进一步通信。
	- Accept()
		- 该方法__创建新的Socket (该套接字中既包含了本机的IP地址和端口号，也包含了客户端的IP地址和端口号。然后就可以利用此套接字与该客户端进行通信了)。__以处理连接请求。当程序执行到该方法时__会处于阻塞状态__，直到有新的客户机请求连接。该方法__返回包含客户端信息的套接字句柄__。
	- Connect()
		- 客户机独有。通过__输入远程设备的IPEndPoint对象(ip+port)__，建立于远程设备的连接。客户端与服务器端建立连接之前，系统不会执行Connect语句下面的语句，而是处于阻塞状态。
	- Send()和Receive()
		- 这两个方法在完成客户端的连接后，将数据发送到连接到的Socket上以及将数据从连接的Socket接收到缓冲区的指定位置。__当Receive方法没有可读的数据时，将一直处于阻塞状态。__
	- ShutDown()
	- Close()
		- 该方法关闭远程主机连接，并释放所有与Socket关联的资源。关闭后，Connected属性将设置为false。
		- 对于面向连接的协议，先调用Shutdown方法，再调用Close方法，以确保在已连接的套接字关闭之前，已发送和接收该套接字上的所有数据。



### 面向连接的套接字
#### 工作流程

<img src="C:\Users\king-kong\Desktop\要做的事情\picture\C#\C#网络编程\有连接套接字工作流程.PNG" style="zoom:30%;" />

##### Connect时的三次握手
![]()

##### Close时的四次挥手
![]()

#### 实战
1. 客户端程序

<img src="C:\Users\king-kong\Desktop\要做的事情\picture\C#\C#网络编程\有连接_client.PNG" style="zoom:33%;" />

2. 服务器端程序

<img src="C:\Users\king-kong\Desktop\要做的事情\picture\C#\C#网络编程\有连接_server.PNG" style="zoom:33%;" />


### 无连接的套接字
#### 工作流程

<img src="C:\Users\king-kong\Desktop\要做的事情\picture\C#\C#网络编程\无连接套接字工作流程.PNG" style="zoom:30%;" />


#### 实战
1. 接受端程序

<img src="C:\Users\king-kong\Desktop\要做的事情\picture\C#\C#网络编程\无连接_接收端.PNG" style="zoom:33%;" />

2. 发送端程序

<img src="C:\Users\king-kong\Desktop\要做的事情\picture\C#\C#网络编程\无连接_发送端.PNG" style="zoom:33%;" />


## 数据流concept
- 是什么
	当通过网络传输数据，或对文件数据进行操作时，需要将数据转化为数据流的形式。数据流（stream）是对__串行传输的数据（以字节为单位）的一种抽象表示__，数据源可以是文件、外部设备、主存、网络套接字等。
- 数据流分为:
	- 文件流
	- 内存流
	- 网络流

### NetworkStream类（网络流）
__是什么__
1. NetworkStream类相当于在网络数据的源端和目的端之间架起了一个数据桥梁，使得读取和写入数据只针对这个通道进行。==但NetworkStream类只支持面向连接的套接字。==
	![]()


__why need 网络流？？__
1. socket不是有send 吗 为什么还要使用网络流

__网络流(NetworkStream类)收发数据流程__

![]()

__NetworkStream类常用属性和方法__

![]()


__NetworkStream类 + Socket__

__NetworkStream类 + TcpClient__


## 网络数据的编码与解码




### C#中的编码与解码类
#### Encoding类
__是什么__
1. Encoding类位于System.Text命名空间中，主要用于在不同的编码和Unicode之间进行转换。

__Encoding类常用的属性和方法__

![]()



__实例：unicode字符串转为UTF-8字符串__
```
string unicodeString="unicode字符串pi(\u03a0)";￼  

//Encoding不是静态类，需要实例化来使用
Encoding Unicode=Encoding.Unicode;￼     
Encoding utf8=Ecoding.UTF8;

//将抽象字符串(字符序列)，按unicode字符集来编码为bit流(按Bytes分块)
byte[] unicodeBytes=unicode.GetBytes(unicodeString);

//在byte[]级别进行转换
byte[] utf8Bytes = Encoding.Convet(Encoding.Unicode,Encoding.UTF8,unicodeBytes);

//再将01序列 ->按utf-8字符集 -> 抽象字符串
string utf8String=utf8.GetString(utf8Bytes);

```

#### Encoder类 和 Decoder类

- 是什么
	- 使用GetBytes() 和Decoder类的GetChars() 来将 "抽象字符序列" -> bytes流 -> “抽象字符序列”，这也一个转换的功能。
	- Encoder类 和 Decoder类实例的构造方式比较特殊，且两者要采用同一种字符集来编解码，如：Encoding.ASCII、Encoding.UTF8


- __why 有了Encoding 还需要 Encoder + Decoder？？__
	1. 在网络传输和文件操作中，如果数据量比较大，需要将其划分为较小的块。__对于跨块传输的情况，直接使用Encoding类的GetBytes方法编写程序比较麻烦__，而Encoder和Decoder由于维护了数据块结尾信息，则可以轻松地实现跨块字符序列的正确编码和解码，因此它们在网络传输和文件操作中很有用。


- Encoder Decoder编解码的步骤：
	1. 获取Encoder Decoder实例
		- //获取ASCII编码的Encoder实例￼：
			Encoder ASCiiEncoder=Encoding.ASCII.GetEncoder();￼
		- //获取Unicode编码的Encoder实例￼：
			Encoder unicodeEncoder=Encoding.Unicode.GetEncoder();

	2. 使用Encoder实例的GetByteCount()方法，计算转换后产生的bytes数组的长度
	3. 使用Encoder实例的GetBytes()方法 + 2.中求出的长度 -> 将字符序列转换为bytes数组
	4. 使用Decoder实例的GetCharCount()方法，计算bytes数组按指定的字符集(如：utf8)转换为的字符序列的长度
	5. 使用Decoder实例的GetChars()方法 + 4.中求出的字符序列长度 -> 将bytes数组转换为字符序列
	![实例]()


# C#网络传输程序开发

## TCP网络程序开发
### 使用Socket进行TCP网络传输


### 使用TCP类进行TCP网络传输

因为使用Socket来进行网络传输实在是太罗嗦低效率了，为了简化网络编程的复杂度，.NET对套接字进行了封装，封装后的类就是TcpListener类和TcpClienr类。
#### TcpListener类
##### TcpListener类的常用属性和方法
1. 常用属性：
2. 常用方法：
	![]()
	1. TcpListener类构造函数。构造了TcpListener对象后，就可以__监听__客户端的连接请求了。有如下两种方式构造：
		1. TcpListener（IPEndPoint iep）
		2. TcpListener（IPAddress localAddr, int port）
	2. AcceptSocket()
		- 同步阻塞方式下获取并返回一个用来接收和发送数据的套接字对象，同时从传入的连接队列中移除该客户端的连接请求。该套接字包含了本地和远程主机的IP地址和端口号，然后通过调用Socket对象的Send方法和Receive方法和远程主机进行通信
	3. AcceptTcpClient()
		- 方法用于在__同步阻塞方式__下获取并返回一个可以用来接收和发送数据的封装了Socket的TcpClient对象。
	4. Start()
		- Start方法被调用后，将自己的LocalEndPoint和底层Socket对象绑定起来，并自动调用Socket对象的Listen方法开始监听来自客户端的请求。如果接收了一个客户端请求，Start方法会自动将该请求插入请求队列，然后继续监听下一个请求，直到调用Stop方法停止监听。当TcpListener接收的请求超过请求队列的最大长度或小于0时，等待接收连接请求的远程主机将会抛出SocketException类型的异常。
	5. Stop()
		- 程序执行Stop方法后，会立即停止监听客户端连接请求，并关闭底层的Socket对象。等待队列中的请求将会丢失，等待接收连接请求的远程主机会抛出套接字异常。


----

__TcpListener和TcpClient一样都提供了同步方法和异步方法。__

----


#### TcpClient类
##### TcpClient类的常用属性和方法
1. 常用属性：
2. 常用方法：
	![]()
	1. 构造函数。
		1. TcpClient()。
			- 该构造函数创建一个默认的TcpClient对象，该对象自动选择客户端尚未使用的IP地址和端口号。创建该对象后，即可用Connect方法与服务器端进行连接。
		2. TcpClient（AddressFamily family）
			- 该构造函数创建的TcpClient对象也能自动选择客户端尚未使用的IP地址和端口号，__但是使用AddressFamily枚举指定了使用哪种网络协议__。创建该对象后，即可用Connect方法与服务器端进行连接。
		3. TcpClient（IPEndPoint iep）
			- 当客户端的主机有一个以上的IP地址时，可使用此构造函数选择要使用的客户端主机IP地址。创建该对象后，即可用Connect("serverIP", serverPort)方法与服务器端进行连接。
		4. TcpClient（string hostname, int port）
			- 这是使用最方便的一种构造函数。该构造函数可直接指定服务器端域名和端口号，而且==无须使用connect方法==。客户端主机的IP地址和端口号自动选择。


#### 使用TcpClient TcpListener编写TCP应用程序一般步骤：

##### 编写服务器端TCP应用程序一般步骤：
1. 创建一个TcpListener对象
2. 然后调用该对象的Start方法在指定的端口进行监听。示例代码：
￼![]()
3. 在单独的线程中，首先循环调用AcceptTcpLient方法接收客户端的连接请求，从该方法的返回结果中得到与该客户端对应的TcpClient对象，并利用该对象的GetStream方法得到NetworkStream对象；然后利用该对象得到其他使用更方便的对象，例如BinaryReader对象、BinaryWriter对象，为进一步与对方通信做准备。示例代码：
![]()
￼
4. 每得到一个新的TcpClient对象，就创建一个与该客户对应的线程，在线程中与对应的客户进行通信。例如：
```c#
Thread threadReceive=new Thread(ReceiveMessage);￼
threadReceive.Start();
```
其中，ReceiveMessage是接收消息的方法。
5. 根据传送的情况确定是否关闭与客户机的连接。
```c#
if(br！=null)￼{￼       
	br.Close();￼
}￼
if(bw！=null)￼   
{￼
	bw.Close();￼     
}￼     
if(tcpClient！=null)￼     
{￼         
	tcpClient.Close();￼     
}
```
在关闭连接之前，要先关闭读写流br和bw。
6. 在停止服务后，服务器可以断开监听：
```c#
￼tcpListener.Stop();
```
##### 编写客户端TCP应用程序一般步骤：
1. 利用TcpClient的构造函数创建一个TcpClient对象。
```c#
private TcpClient tcpClient;￼
tcpClient=new TcpClient();
```
2. 使用Connect方法与服务器连接。
```c#
tcpClient.Connect(remoteHost.HostName,5656);
```
3. 使用TcpClient对象的GetStream方法得到网络流，然后利用该网络流与服务器进行数据传输。
```c#
if(tcpClient！=null)￼{￼        
statusStrip1.Invoke(showStatus,"连接成功！");￼           networkStream=tcpClient.GetStream();￼
br=new BinaryReader(networkStream);￼  
bw=new BinaryWriter(networkStream);￼
}
```
4. 创建一个线程监听指定的窗口，循环接收并处理服务器发送过来的信息。
```c#
￼Thread threadReceive=new Thread(ReceiveMessage);￼   
threadReceive.Start();
```
其中，ReceiveMessage方法用来循环接收消息。
5. 完成工作后，向服务器发送关闭消息，并关闭与服务器的连接。






### 同步和异步
利用TCP开发应用程序时，.NET框架提供两种工作方式，一种是同步工作方式（syschronization），另一种是异步工作方式（asynchronous）。

#### 同步TCP
- 是什么
	- 同步工作方式是指利用TCP编写的程序执行到__监听（accept）__或__接收（receive）__语句时，在未完成当前工作（侦听到连接请求或收到对方发来的数据）前不再继续往下执行。

##### 使用同步TCP的一般步骤为：
###### 服务器端
1. 创建一个包含采用的网络类型、数据传输类型和协议类型的__本地套接字对象__，并将其与服务器的IP地址和端口号__绑定__。这个过程可以通过Socket类或者TcpListener类完成。
2. 在指定的端口进行__监听__，以便接收客户端的连接请求。
3. 一旦__接收__了客户端的连接请求，就根据客户端发送的连接信息创建与该客户端对应的Socket对象或者TcpClient对象。
4. 根据创建的Socket对象或者TcpClient对象，分别与每个连接的客户进行数据传输。
5. 根据传送信息情况确定是否关闭与对方的连接。

###### 客户端
1. __创建__一个包含传输过程中采用的网络类型、数据传输类型和协议类型的Socket对象或者TcpClient对象。
2. 使用__Connect__方法与远程服务器建立连接。
3. 与服务器进行数据传输。
4. 完成工作后，向服务器发送关闭信息，并关闭与服务器的连接。
	- 通过发送一些特殊的字符串来控制连接关闭


##### 实例




#### 异步TCP
- 是什么
	异步工作方式是指程序执行到监听或接收语句时，不论当前工作是否完成，都会继续往下执行。


### 实战：使用TCP实现网络聊天室
#### 基于同步TCP的网络聊天室开发

#### 基于异步TCP的网络聊天室开发



## UDP网络程序开发
### 使用Socket实现UDP

### 使用UdpClient类实现UDP
- __.NET库中的UdpClient类对基础Socket进行了封装__，发送和接收数据时不必考虑底层套接字在收发时必须要处理的细节问题，在一定程度上降低了UDP编程的难度，提高了编程效率。

- TCP有TcpListener和TcpClient两个类，而UDP只有UdpClient一个类，位于System.Net.Sockets命名空间中。这是__因为UDP是无连接的协议，所以只需要一种封装后的Socket__。

#### UdpClient类

UdpClient类的__常用属性__
![]()
UdpClient类的__常用方法__

1. 构造方法：UdpClient拥有6种重载的构造函数，对于IPv4来说，常用的重载形式有4种。因为UDP接收端发送端均使用UdpClient类，故UdpClient类的构造对于发送端和接受端分别有不同的适合的构造方式。
	1. public UdpClient（）
		- 此构造函数创建一个新的UdpClient对象，并__自动分配__合适的__本地__IPv4地址和端口号，但该构造函数__不执行套接字绑定__。如果使用这种构造函数，在发送数据报之前，必须先调用Connect方法，而且只能将数据报发送到Connect方法建立的远程主机。用法如下：
			1. UdpClient udpClient = new UdpClient();￼
			2. udpClient.Connect("www.cqut.edu.cn",51666); //指定默认远程主机和端口号￼
			3. Byte[] sendBytes = Encoding.Unicode.GetBytes("你好！");￼ //约定编解码字符集
			4. udpClient.Send(sendBytes,sendBytes.Length); //发送给默认主机
	2. public UdpClient（int port）
		- 这种形式是创建UdpClient对象最方便、最简单的方式。__这个port是本地的port__，可以直接指定，也可以端口号置为0，表示让系统自动为其分配一个合适的端口号，这样就不会发生端口号冲突的情况。
	3. public UdpClient（IPEndPoint localEp）
		- 接收端UDP使用这种比较合适，因为localIPEndPoint是一个IPEndPoint（网络端点）类型的对象实例，__封装的是本地的IP + 端口号__
		- 。这样一来，只要远程主机使用这个IPEndPoint中的IP和port，就可以直接向本机的指定端口发送数据报。用法如下：
			1. IPAddress  localIp = Dns.GetHostAddress( Dns.GetHostName() )[0];￼   
			2. IPEndPoint  localIPEndPoint = new IPEndPoint(localIp ,51666);￼    
			3. UdpClient  udpClient = new UdpClient(localIPEndPoint );
	4. public UdpClient（string hostname, int port）
		- __这个string hostname, int port是对方端的__，本地端会自动分配合适的IP地址和port。__这种构造相当于将Connect合为一体了，故只能用于向特定端发送数据 or 从特定端接收数据__。用法如下：
			1. UdpClient udpClient=new UdpClient("www.cqut.edu.cn",51666);






#### 使用UdpClient类实现UDP的一般步骤


### 同步和异步


### 实战：UDP的广播||组播程序开发 
#### 多播
- 是什么

- 优缺点
	- 优点:
		不需要像组播那样多了加入组播组和退出组播组的步骤。即，对于恰好是想要想整个子网广播的情况最适合。
	- 缺点：
		粒度太大，只能向整个子网为单位广播。但是，对于跨子网的、子网内有的主机不想接的情况都不行


- 广播分两种类型：
	1. 本地广播：只向某一子网中的all主机发送消息
		- 为了让发送的消息能被子网内all主机收到，发送的广播消息必须包含一个特殊的IP地址：这个IP地址的主机号的二进制表现形式全为1，例如：子网号为192.168.0.0的广播地址为192.168.0.255
	2. ~~全球广播：向全球all网络设备发送消息。路由器会自动过滤全球广播，这种方式已经被弃用了。~~
		- ~~全球广播的广播消息包含的特殊IP地址为:255.255.255.255。~~

- IP广播的使用步骤：
	1. 

#### 组播
- 是什么
	
- why need it
	用来弥补广播的不足。

- 优缺点
	- 优点：
		1. 可以跨多个子网。组播组是开放的，任何位于不同子网的都可以随时加入组播组、随时退出组播组。一旦加入，便会被广播，一旦退出，就不会再被广播。
		2. 可以自定义广播到哪些主机，是通过引入一个组播组的概念实现的。
	- 缺点：

- 注意：
	1. 组播地址范围是224.0.0.0～239.255.255.255的D类IP地址。任何发送到组播地址的消息都会被发送到组内的所有成员设备上。
	2. 大多数的组播是临时的，仅在有成员的时候才存在，用户创建一个新的组播组时，只需从地址范围内选出一个地址，然后为这个地址构造一个对象，就可以开始发送消息了。
		- ==这些是公网，万一和另一个人冲突了怎么办？？？==
	3. 使用组播时要注意TTL（Time to live，生存周期）值的设置。TTL是允许路由器转发的最大次数，默认情况下，TTL的值为1，如果使用默认值，则只能在子网内发送。可以使用下列两种方式来更改ttl:
		1. UdpClient对象提供了一个Ttl属性，可以利用它修改TTL的值。
		2. 在UdpClient对象使用JoinMulticastGroup加入组播组时设置。
			- udpClient.JoinMulticastGroup(IPAddress.Parse("224.100.0.1"),8);

- IP组播的使用步骤：

#### 基于广播和组播的网络会议程序开发
- 是什么
	通过Internet实现群发功能的形式有两种：
	1. 一种是利用广播向子网中的所有用户发送信息，例如各种通知、公告、集体活动日程安排等；
		- ==西电导航里的群发通知，也是这么做的??????==
	2. 另一种是利用组播向Internet上不同的子网发送信息，例如集团向其所属的公司或用户子网发布信息公告等。


- 组播和广播可以结合着使用。
	- 登录的时候，用到了广播。进入会议、讨论聊天和更新成员列表则用到了组播。


- 功能介绍：

- 具体实现：


## RawSocket网络程序开发



## P2P网络程序开发

- 是什么
	在P2P技术尚未风行之前，几乎所有的网络应用都是采用C/S架构或者B/S架构。P2P架构与传统架构C/S不同，使用P2P技术实现的每个计算机节点既是客户端，也是服务器，其功能的提供是对等的，每个计算机节点根据自己的计算能力，同时承担了一部分服务器功能

### P2P相对于C/S的优缺点

### P2P系统的分类
使用P2P方式架构的系统可以分为两大类：
1. 一类是单纯型P2P，没有专用的服务器；
	__单纯型P2P系统中的各个节点之间直接交互信息__。这种方式的优点是不依赖于专用的服务器，任何一台计算机只要安装同一个P2P应用软件，就可以和其他安装这个软件的计算机直接通信。
2. 另一类是混合型P2P，即单纯型和专用服务器相结合的架构。
	混合型P2P将单纯型P2P和C/S架构相结合，它和传统C/S的区别在于：传统C/S架构的所有资源都存放在服务器中，所有的传递内容都经过服务器；__而对于混合型P2P来说，此时的服务器仅仅起到促成各节点协调和扩展的作用，一般称这种服务器为索引服务器__。在这种架构下，资源不是全部存储在服务器上，而是分布在各个计算机上。



### 主流P2P应用分类
依据技术实现上的差别，当前P2P网络应用大致可以分为文件共享类应用、即时通信类应用，多媒体传输类应用。
1. 文件共享类应用：
	文件共享类应用俗称“文件下载”，是大家平时上网下载东西时最常用到的。例如，迅雷、BT等软件都是文件下载的典型应用。
2. 即时通信类应用：
3. 多媒体传输类应用：
	多媒体传输类应用也称“流媒体播放”，是近年来悄然兴起的Internet视频直播软件应用。这类软件使用网状结构，支持多种格式的流媒体文件，节点间动态查找就近连接。

### P2P通信步骤
在所有的P2P应用中，对等节点首先必须能够彼此发现对方，一旦找到提供P2P服务的计算机节点，就可以直接与它通信。即P2P应用的通信由__发现__、__连接__和__通信__3个步骤组成。
1. 发现阶段
	- 一台计算机要和另一台计算机通信，__必须知道对方的IP地址和监听端口号__。
2. 连接阶段和通信阶段
	- 完成对等节点定位和资源搜索之后，就可以根据需要，选择TCP、UDP或者其他协议完成数据传输。
		- 如果选择TCP，则首先需要在对等结点之间建立连接，而后利用该连接在对等结点之间传送数据；
		- 如果选择UDP，则无须建立连接，直接在对等节点之间通信即可。


### .NET下的P2P程序开发
#### PNRP协议
- 是什么
	1. 对等名称解析协议（Peer Name Resolution Protocol, PNRP），完成对等名称的注册和解析。
		- 名称注册：
			- 任何资源若要被网络上的其他主机识别到，首先必须注册到P2P网络。名称注册就是将包含对等节点信息的对等名发布到云中，以便其他对等节点解析。
		- 名称解析：
			- 名称解析是指利用对等名称获取注册到云中的资源所在对等节点的IP地址和端口号的过程。
	2. PNRP只负责让对等端相互间知道各自的IP + port，这样就完成了P2P的发现阶段，后续的连接、通信阶段，就只是前面讲的普通的使用TCP/UDP等传输层协议了。可以说，单纯性P2P的核心就是PNRP协议，只不过像BT下载那种P2P应用，基于TCP/UDP层设置了别的复杂的理论优化，如：将大文件切成小文件，从多个对等端上接受(即，PnP)来实现的下载速度快。






# Internet应用程序开发

## FTP网络程序开发

### FTP原理及规范

#### FTP协议||文件传输服务
- 文件传输任务
	1. 信息共享 -> 文件传输需求 -> 文件传输服务程序 <- 基于FTP协议设计
	2. 文件传输服务是由FTP应用程序提供的，而FTP应用程序遵循的是TCP/IP中的文件传输协议，它允许用户将文件从一台计算机传输到另一台计算机，并且能保证传输的可靠性。

- FTP协议：	
	- 是应用层协议，是在RFC959中说明的。该协议定义了远程计算机系统和本地计算机系统之间传输文件的一个标准。
		- TCP/UDP不是能传输文件吗？？why还要专门定义一个FTP应用层协议来传文件。

- FTP功能：
	1. 提供文件的共享，包括程序文件和数据文件。
	2. 支持间接使用远程计算机。
	3. 使用户不因各类主机文件存储器系统的差异而受影响。
	4. 利用TCP提供可靠且有效的传输。



- 注意：
	- 一般来说，传输文件的用户需要先经过认证以后才能登录远程服务器，然后访问远程服务器中的文件。__而大多数的FTP服务器往往提供一个GUEST的公共账户来允许未注册用户访问该FTP服务器。__


#### FTP与HTTP区别
- 同：
	1. 传输层协议均基于TCP协议
- 异：
	1. 

#### FTP的特点：why对于文件上传|下载需求 FTP比HTTP smtp 更适合？？？？


### .NET下FTP相关类

### 实战：


## SMTP与POP3网络程序开发技术


### 邮件发送&&SMTP

- 是什么
	- 邮件发送需求 -> 基于TCP的SMTP应用层协议的设计 -> 基于SMTP协议的程序(SMTP协议的具体实现)

- SMTP的2种工作方式：
	1. 一种是使用匿名方式发送邮件，称为SMTP；
	2. 另一种是客户端必须提供用户名密码认证，称为ESMTP（Extentded SMTP）

- 客户端发送电子邮件的过程：
	1. 先通过客户端将邮件发送到SMTP邮件服务器	----	__上传__
		1. 客户端先与服务器__建立连接__
			1. 客户端发送“EHLO Local”命令，服务器收到后返回“220”响应码，表示服务器准备就绪。
			2. 客户端发送“AUTH LOGIN”命令，服务器收到后返回“334”响应码，表示要求用户输入用户名。
			3. 客户端发送经过Base64编码处理的用户名，服务器收到并经认证成功后返回“334”响应码，表示要求用户输入密码。
			4. 客户端发送经过Base64编码处理的密码，服务器收到并经认证成功后返回“235”响应码，表示认证成功，用户可以发送邮件。
		2. 客户端开始发送__邮件的信封__
			1. 客户端发送“MAIL FROM：＜发信人的地址＞”命令，服务器收到后返回“250”响应码，表示请求操作就绪。
			2. 客户端发送“RCPT TO：＜收信人的地址＞”命令，服务器收到后返回“250”响应码，表示请求操作就绪。
		3. 客户端开始发送__邮件数据__
			1. 客户端发送“DATA”命令，表示开始向服务器发送邮件数据，包括邮件的首部和正文。
			2. 客户端发送邮件首部。
			3. 客户端发送正文。
		4. 客户端和服务器__断开连接__

	2. 再通过当前的服务器发送到下一个目标SMTP邮件服务器	----	__中转__

#### SMTP的特点：why邮件发送smtp比http ftp适合？？


### 邮件接收&&POP3

- POP3
	- POP3允许客户端连接到服务器并且将所有的邮件下载到客户机的邮箱中。
	- POP3邮局服务器通过__侦听TCP端口110__提供POP3服务。
	- __客户端读取邮件之前，需要先与服务器建立TCP连接__。连接成功后，POP3服务器会向该客户端发送确认消息。然后客户端根据服务器回送的信息决定下一步的操作。
	- POP3规定__每条命令均由命令和参数两部分组成__，每条命令都以回车（CR）换行（LF）结束，命令和参数之间由空格间隔。
	- POP3服务器回送的__响应信息由状态码和附加信息（可选）组成__。所有响应也都以回车（CR）换行（LF）结束。其中，状态码有以下两种:
		- +OK：表示正确执行了客户端发送的命令。
		- -ERR：表示服务器执行命令失败。


#### POP3的特点：why邮件接收pop3比http ftp 高效


### .NET下的邮件收发相关类

### 实战：邮件客户端程序设计






## 基于HTTP的Web程序开发技术

- 是什么
	- (万维网下任意传输Web页面)需求 -> HTTP协议 -> Web服务器(HTTP协议的实现)

### HTTP协议概述

- 是什么
	- [两点]之间传输[超文本数据]的约定和规范。
		- 两点之间可能是 服务器 <->本地浏览器，也可以是 服务器 <-> 服务器，可不可以是 本地浏览器 <-> 本地浏览器 ？？？？

- HTTP工作流程：
	- 通过__HTTP请求__ 和 __HTTP响应__来工作：HTTP客户端首先与服务器建立TCP连接，然后客户端通过套接字发送HTTP请求，并通过套接字接收HTTP响。


- HTTP性能的决定因素：
	- HTTP 协议是基于 TCP/IP，并且使⽤了「请求 - 应答」的通信模式，所以性能的关键就在这两点⾥。


#### HTTP请求||HTTP响应
##### HTTP请求
- HTTP请求的书写格式：
	1. 在HTTP请求中，第一行必须是一个请求行（request-line），说明请求类型、要访问的资源以及使用的HTTP版本；如：
		- GET / HTTP/1.1
		- GET方法：
			-  
	2. 紧接着是标头（header）部分，说明服务器要使用的附加信息，这部分一般由多行组成；如：
		- Connection: Keep-Alive
			- 常用于客户端要求服务器使用长连接，以便其他请求复用而不用每次都建立-关闭TCP连接
			- HTTP/1.1的默认连接都是长连接，但为了兼容老版本的HTTP，需要显式指定Connection：Keep-Alive
		- Host: www.A.com 
			- 有了Host字段，可以将请求发往同一台服务器上的不同网站。如：
			- ![小林的图]()
		- Conenction-Type字段
			- 一般用于
		- Accept: */*
			- 我不挑，我能接受所有数据格式。对应的是http相应的header中的Content-Type字段
		- Accept-Encoding: gzip, deflate
			- 配合返回的Content-Encoding使用
	3. 标头之后是一个空行（blank line），表明标头结束；
	4. 空行之后是请求的主体（request-body），主体中可以包含任意的数据。如下：
```
    ＜request-line＞￼ 
    ＜headers＞￼   
    ＜blank line＞￼   
    [＜request-body＞]
```

- 如：
```

```


- 注意：
	1. 一是请求的方法名称区分大小写，
	2. 二是HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。
	3. 如果服务器不支持客户端发送的请求方法，则服务器将返回错误并立即关闭连接。

##### HTTP响应
- HTTP响应的一般格式：
	- 对于HTTP响应来说，它与HTTP请求相比，__唯一的区别__是第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个__状态码__来说明所请求的资源情况。
		1. 所有HTTP响应的__第一行都是状态行__，该行内容依次是当前__HTTP版本号__、__3位数字组成的状态码__以及__描述状态的短语__，各项之间__用空格分隔__。
		2. __状态行之后是标头信息__。
			- Date:
			- Content-Type: text/html; charset=utf-8
			- Content-Encoding: gzip
				- 表示服务器返回的数据使用了什么压缩格式。一般配合HTTP请求的Header中的Accept-Encoding字段。
		4. 响应主体所包含的就是所请求资源的HTML源文件内容。
```
   ＜status-line＞￼ 
   ＜headers＞
   ＜blank line＞￼  
   [＜response-body＞]
```

- 五大类HTTP状态码：
	![]()

#### Get和Post

##### Get方法

##### Post方法


#### HTTP发展和演进

![HTTP协议进化图]()

##### HTTP/1.0
- 在早期的HTTP 1.0中，定义了3种最基本的请求类型：GET、POST和HEAD。
- 客户端程序用大写指令将请求发送给服务器，后面跟随具体的数据。由于这些请求的类型实际上是告诉服务器采用什么方法（method）来处理客户端的请求，所以也将这些请求的类型称为请求的方法。





##### HTTP/1.1
###### HTTP/1.0 -> HTTP/1.1概述
- HTTP 1.1提供了8种HTTP请求的方法
	![]()
	- 虽然HTTP 1.1定义了大量的请求类型，但是对于程序员来说，一般关心的只有GET请求和POST请求。



- 相较于HTTP/1.0的新增特点：
	1. 长连接
		- 早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是 串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。
		- 为了解决上述 TCP 连接问题，HTTP/1.1 提出了⻓连接的通信⽅式，也叫持久连接。这种⽅式的好处在于减少了 TCP 连接的重复建⽴和断开所造成的额外开销，减轻了服务器端的负载。
		- 持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。
	2. 管道网络传输
		- 是什么
			- HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。__即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第 ⼆个请求出去__，可以减少整体的响应时间。
	3. 队头阻塞
		- 是什么
			- 但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求 排队等着。这称为「队头堵塞」。
			- （管道网络传输 -> 服务器按顺序回应的特点） + [请求-应答]模式 -> 队头阻塞的风险 (慢火车效应)

- HTTP/1.1性能还是有瓶颈：
	1. 只能压缩Body的部分，请求/响应头部[Header]部分未经压缩就发送，首部信息越多延迟越大。
	2. 发送冗余的Header。每次互相发送相同的首部造成的浪费较多
	3. （管道网络传输 -> 服务器按顺序回应的特点） + [请求-应答]模式 -> 队头阻塞的风险 (慢火车效应)
	4. 没有请求优先级控制
	5. 请求只能从客户端开始，服务器只能被动响应。(==那你之前说，也能 服务器 <-> 服务器==)


- 总之， HTTP/1.1 的性能⼀般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。


###### HTTP/1.1还能怎么优化(除了HTTP/1.1 -> HTTP/2中的改进)
1. 使用KeepAlive将HTTP/1.1从短连接 -> 长连接(HTTP/1.1本身不就是默认长连接吗？？？意思是不是因为为了与低版本兼容HTTP/1.1必须显式声明长连接这个意思？？？)
2. 尽量避免发送重复的HTTP请求
	- 缓存
		1. why can
			- 对于⼀些具有重复性的 HTTP 请求，⽐如每次请求得到的数据都⼀样的，我们可以把这对「请求-响应」的 数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过⽹络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定⾁眼可⻅的提升。
		2. how
			- HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的 头部有不少是针对缓存的字段。
			- 缓存字段干了什么？
				- 客户端会把第⼀次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，⽽响应作为 value，两者 形成映射关系。这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就 直接从本地读取该响应。毋庸置疑，读取本次磁盘的速度肯定⽐⽹络请求快得多
			- 同一个url对应的缓存过期怎么办？？(服务器对同一url的内容刷新了，缓存却不能同步)
				1. 资源过期时间
					- 服务器在发送 HTTP 响应时，__会估算⼀个过期的时间，并把这个信息放到响应头部中__，这样客户端在查看响 应头部的信息时，⼀旦发现缓存的响应是过期的，则就会重新发送⽹络请求。
			- 再次请求同一url时，发现到了过期时间，但是请求server发现估算的不准，实际资源并没有更新时，怎么优化？？
				- 只需要客户端在重新发送请求时，在请求的 Etag 头部带上第⼀次请求的响应头部中的摘要，这个摘要是唯⼀标 识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个⽐较。
					- 如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。 
					- 如果相同，说明客户端的缓存还是可以继续使⽤的，那么服务器仅返回不含有包体的 304 Not Modified 响应， 告诉客户端仍然有效，这样就可以减少响应资源在⽹络中传输的延时，如下图：
					![]()

3. 在需要发送HTTP请求时，考虑减少请求次数
	- 减少重定向请求次数
		- ![原始的重定向开销]()
		1. 将重定向的工作由客户端发起交由代理服务器发起，能减少1/4 HTTP请求次数，如下图：
		- ![客户端->代理服务器]()
		2. 将源服务器的重定向规则交由代理服务器完成，能进一步减少消息传递次数。如下图：
		- ![源服务器->代理服务器]()
	- 合并请求
		- why can
			1. 对于同一个TCP管道的HTTP任务合并：
				- 如果把多个访问⼩⽂件的请求合并成⼀个⼤的请求，虽然传输的总资源还是⼀样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。
			2. 对于多个TCP管道的HTTP任务合并：
				- 另外由于 HTTP/1.1 是请求响应模型，如果第⼀个发送的请求，未收到对应的响应，那么后续的请求就不会发送， 于是为了防⽌单个请求的阻塞，所以⼀般浏览器会同时发起 5-6 个请求，每⼀个请求都是不同的 TCP 连接，那么如果合并了请求，也就会减少TCP连接的数量，因⽽省去了TCP握⼿和慢启动过程耗费的时间。
		- how
			1. 请求多次小的合成请求一次大的。
				1. 使用CSS Image Sprite技术将请求多次小图片合成请求一次大图片。
					- 有的⽹⻚会含有很多⼩图⽚、⼩图标，有多少个⼩图⽚，客户端就要发起多少次请求。那么对于这些⼩图⽚，我们 可以考虑使⽤ CSS Image Sprites 技术把它们合成⼀个⼤图⽚，这样浏览器就可以⽤⼀次请求获得⼀个⼤图⽚， 然后再根据 CSS 数据把⼤图⽚切割成多张⼩图⽚。
				2. 还有服务端使⽤ webpack 等打包⼯具将 js、css 等资源合并打包成⼤⽂ 件，也是能达到类似的效果。(本质也是：请求多次)
				- ==缺点：==
					- 当⼤资源中的某⼀个⼩资源发⽣变化后，客户端必须重新下载整个完整的⼤ 资源⽂件，这显然带来了额外的⽹络消耗。
			2. 直接嵌入来省去HTTP请求
				
				- 还可以将图⽚的⼆进制数据⽤ base64 编码后，以 URL 的形式潜⼊到 HTML ⽂件，跟随 HTML ⽂件⼀并 发送。这样客户端收到 HTML 后，就可以直接解码出数据，然后直接显示图⽚，就不⽤再发起图⽚相关的请求，这样便减 少了请求的次数。
	- 延迟发送请求
		- why
			- ⼀般 HTML ⾥会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来， 于是可以通过「按需获取」的⽅式，来减少第⼀时间的 HTTP 请求次数。
		- how
			- 只获取当前⽤户所看到的⻚⾯资源，当⽤户向下滑动⻚⾯的时 候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。

4. 减少服务器的HTTP响应的数据大小
	- why can
		- 对于 HTTP 的请求和响应，通常 HTTP 的响应的数据⼤⼩会⽐较⼤，也就是服务器返回的资源会⽐较⼤。于是，我们可以考虑对响应的资源进⾏压缩，这样就可以减少响应的数据⼤⼩，从⽽提⾼⽹络传输的效率。
	- how
		1. 无损压缩	
			- 基于二进制数据的压缩
				1. gzip
				2. br
					- gzip 的压缩效率相⽐ Google 推出的 Brotli 算法还是差点意思，也就是上⽂中的 br，所以如果可以，服务器应该选 择压缩效率更⾼的 br 压缩算法。
		2. 有损压缩
			- 静态图片的压缩
				1. Google 推出的 WebP 格式
			- 动态音视频的压缩
				1. 视频
					- VPx：VP8 VP9 AV1
					- H26x：H264 H265
				2. 音频
					- 
5. 提升并发能力：
	
	- 将同⼀个⻚⾯的资源分散到不同域名，提升并发连接上限，因为浏览器通常对同⼀域名的 HTTP 连接最⼤只 能是 6 个；一般浏览器只对同域名(即，同一服务器的访问)的并发数有限制(如：之前看学在西电的时候使用chrome只能同时播放6个，第7个打不开)，但是对不同域名没有限制：可以打开相当多的几十上百个页面。



- 不管怎么优化 HTTP/1.1 协议都是有限的，不然也不会出现 HTTP/2 和 HTTP/3 协议，后续我们再来介绍 HTTP/2 和 HTTP/3 协议。



##### HTTP/2
###### HTTP/1.1 -> HTTP/2概述
- 在HTTP/1.1基础上新增的特点：
	1. 安全上：
		- 默认基于HTTPS
	2. 性能上：
		1. 头部压缩
			- HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。
			- 这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索 引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。
		2. 全面采用二进制格式
			- HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并 且统称为帧（frame）：头信息帧和数据帧。
			- ![]()
			- 好处：
				- 这样虽然对⼈不友好，但是对计算机⾮常友好，因为计算机只懂⼆进制，那么收到报⽂后，⽆需再将明⽂的报⽂转 成⼆进制，⽽是直接解析⼆进制报⽂，这增加了数据传输的效率。
		3. 管道网络传输 -> 数据流
			- HTTP/2 的数据包__不是按顺序__发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，__必须要对数据包做标记，指出它属于哪个回应。__每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中__规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数__
			- 客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。
		4. 多路复用
			- HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。
			- 移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼ 了连接的利⽤率。
			- 举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就 回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。
		5. 服务器推送(服务不再是被动地响应，也可以主动向客户端发 送消息)
			- HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发 送消息。
			- 举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减 少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。




- HTTP/2.0仍有缺陷：
	1. HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求 的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等 待这个丢了的包被重传回来。
		- HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了
		- HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。
	- 解决办法：HTTP/3将底层的TCP 换位 UDP + QUIC
		- QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到 影响。(即，哪个http丢包了，自己等去，别的http要开始使用下层的UDP管道了)


###### HTTP2牛逼在哪？
![]()

- 新的需求 -> 旧的HTTP/1.1无法快速增长的需求 -> HTTP/2的诞生


- HTTP/2牛逼在解决了HTTP/1.1存在的很多问题：
	- 新的快速增长的需求：
		1. __消息的⼤⼩变⼤了：__
			- 从⼏ KB ⼤⼩的消息，到⼏ MB ⼤⼩的消息； 
		2. __⻚⾯资源变多了：__
			- 从每个⻚⾯不到 10 个的资源，到每⻚超 100 多个资源； 
		3. __内容形式变多样了：__
			- 从单纯到⽂本内容，到图⽚、视频、⾳频等内容； 
		4. __实时性要求变⾼了：__
			- 对⻚⾯的实时性要求的应⽤越来越多； 
	- HTTP/1.1存在的问题：==主要问题就是HTTP/1.1的延迟太高了==
		1. __延迟难以下降__
			- 虽然现在⽹络的「带宽」相⽐以前变多了，但是延迟降到⼀定幅度后，就很难再下降了，说 ⽩了就是到达了延迟的下限； 
		2. __并发连接有限__
			- ⾕歌浏览器最⼤并发连接数是 6 个，⽽且每⼀个连接都要经过 TCP 和 TLS 握⼿耗时，以及 TCP 慢启动过程给流量带来的影响；
		3. __队头阻塞问题__
			- 同⼀连接只能在完成⼀个 HTTP 事务（请求和响应）后，才能处理下⼀个事务； 
		4. __HTTP 头部巨⼤且重复__
			- 由于 HTTP 协议是⽆状态的，每⼀个请求都得携带 HTTP 头部，特别是对于有携带 cookie 的头部，⽽ cookie 的⼤⼩通常很⼤； 
		5. __不⽀持服务器推送消息__
			- 因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这⽆疑浪费⼤量 了带宽和服务器资源。
	- HTTP/2的解决方案：
		1. 兼容HTTP/1.1
			1. 第⼀点，HTTP/2 没有在 URI ⾥引⼊新的协议名，仍然⽤[http://] 表示明⽂协议，⽤[https://]表示加密协议， 于是只需要浏览器和服务器在背后⾃动升级协议，这样可以让⽤户意识不到协议的升级，很好的实现了协议的平滑升级。
			2. 只在应⽤层做了改变，还是基于 TCP 协议传输，应⽤层⽅⾯为了保持功能上的兼容，HTTP/2 把 HTTP 分 解成了「语义」和「语法」两个部分，「语义」层不做改动，与 HTTP/1.1 完全⼀致，⽐如请求⽅法、状态码、头 字段等规则保留不变。但是，HTTP/2 在「语法」层⾯做了很多改造，基本改变了 HTTP 报⽂的传输格式。
		2. 头部压缩：body使用gzip，br等二进制压缩方式；header使用Hacher来进行压缩
		3. 二进制帧
			- 从对人友好地ASCII文本格式 -> 对计算机解析高效的二进制文本格式，如下图：
				![]()
			- HTTP/2 把响应报⽂划分成了两个帧（Frame），图中的 HEADERS（⾸部）和 DATA（消息负载） 是帧的类型， 也就是说__ HTTP 响应，划分成了两个帧来传输，并且采⽤⼆进制来编码__
				![]()
				- ==帧头很小，只有9字节==
					1. 帧开头的3B表示帧长度
					2. 帧⻓度后⾯的⼀个字节是表示帧的类型，HTTP/2 总共定义了 10 种类型的帧，⼀般分为数据帧和控制帧两类，如 下表格：
						![]()
					3. 帧类型后⾯的⼀个字节是标志位，可以保存 8 个标志位，⽤于携带简单的控制信息，⽐如： 
						- END_HEADERS 表示头数据结束标志，相当于 HTTP/1 ⾥头后的空⾏（“\r\n”）； 
						- END_STREAM 表示单⽅向数据发送结束，后续不会再有数据帧。
						- PRIORITY 表示流的优先级；
					4. 帧头的最后 4 个字节是流标识符（Stream ID），但最⾼位被保留不⽤，只有 31 位可以使⽤，因此流标识符的最⼤ 值是 2^31，⼤约是 21 亿，它的作⽤是⽤来标识该 Fream 属于哪个 Stream，接收⽅可以根据这个信息从乱序的帧 ⾥找到相同 Stream ID 的帧，从⽽有序组装信息。
				- ==最后面是帧数据，存放的是二进制数据通过 HPACK 算法压缩过的 HTTP header和gzip等压缩后的body==
		4. 并发传输
		5. 服务器主动推送资源







##### HTTP/3
###### HTTP2 -> HTTP/3概述

- HTTP/3相较于HTTP/2新增的：
	1. TCP -> UDP + QUIC
		- QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到 影响。	
	2. 头部压缩算法也升级成了 QPack 
	3. TLS3 升级成了最新的 1.3 版本
	4. 减少了建立连接的交互次数。
		- HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接 把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。
		![6此握手->3次握手]()

- 其实，QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复⽤的协议




#### HTTP协议特点：why传输Web文档 使用HTTP比使用FTP SMTP更高效？？？

1. HTTP底层__基于TCP__方式工作
	- HTTP采用TCP传输数据，因此__不会丢失数据__，__也不会出现乱序__的情况。
3. HTTP使用__元信息作为标头__。
	- HTTP通过添加标头（header）的方式向服务器提供本次HTTP请求的相关信息，即在主要数据前添加一部分信息，称为元信息（metainformation）。例如，传送的对象属于哪种类型，采用的是哪种编码等。

- 优点
	1. 简单
		- HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学习 和使⽤的⻔槛。
	2. 灵活-易于扩展
		- HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定 义和扩充。
	3. 跨平台

- 缺点：
	1. 不安全
		- 是什么
			1. 通信使⽤明⽂（不加密），内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。 
			2. 不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了。 
			3. ⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。
		- 不安全问题的解决方案：
			1. HTTP -> HTTPS
				- HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全上达到了极致。



- 双刃剑(即是优点又是缺点)
	1. 无状态
		- 是什么
			- 无状态”的含义是，客户端发送一次请求后，服务器并没有存储关于该客户端的任何状态信息。即使客户端再次请求同一个对象，服务器仍会重新发送这个对象，而不管之前是否已经向客户端发送过这个对象。
		- 好处：
			- 因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的 负担，能够把更多的 CPU 和内存⽤来对外提供服务。
		- 缺点：
			- 既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。如：
				- 登录->添加购物⻋->下单->结算->⽀付，这系列操作都要知道⽤户的身份才⾏。但服务器不知道这些请求是有 关联的，每次都要问⼀遍身份信息。 这样每操作⼀次，都要验证信息，这样的购物体验还能愉快吗？
		- 无状态缺点的解决方案：
			1. Cookies
				- Cookie 通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态。
				![]()
	2. 明文传输
		- 是什么
			- 明⽂意味着在传输过程中的信息，是可⽅便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接⾁眼查 看，为我们调试⼯作带了极⼤的便利性。
		- 好处：
			- 通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接⾁眼查 看，为我们调试⼯作带了极⼤的便利性。
		- 缺点：
			- 但是这正是这样，HTTP 的所有信息都暴露在了光天化⽇下，相当于信息裸奔。在传输的漫⻓的过程中，信息的内 容都毫⽆隐私可⾔，很容易就能被窃取，如果⾥⾯有你的账号密码信息，那你号没了。
		- 明文传输缺点的解决方案：





#### HTTPS 和 HTTP
- HTTP和HTTPS的区别：
	1. HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。
	2. HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之 后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。
		![加入了ssl层]()
	3. HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。
	4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。


- HTTPS解决了HTTP什么问题：
	- 窃听风险 -> 信息加密
	- 篡改风险 -> 效验机制
	- 冒充风险 -> 身份证书

- HTTPS的原理：参考刘磊-极客时间
	1. 混合加密
		- 使用非对称加密交换密钥。因为对称加密只使⽤⼀个密钥，双端想互知这一密钥就要交换，却⽆法做到安全的密钥交换。(只有不交换才能做到绝对的安全)

		- 使用对称加密加密明文
	2. 摘要算法
		- 摘要算法⽤来实现完整性，能够为数据⽣成__独⼀⽆⼆的「指纹」__，⽤于校验数据的完整性，解决了篡改的⻛险。
	3. 数字证书

- HTTPS链接建立流程：(==难==)
	1. 




### .NET下的HTTP相关类




### 实战：基于HTTP的多线程文件下载器





## Web Service程序开发技术













# 其他

1. TCP传输时，为什么Accept会返回新的socket对象？？是为了server连接多个client吗才专门弄一个socket用来接收链接的吗？？

2. TCP传输时，C#只支持发送bytes[]数组，故对于源信息(字符串 or 数值类型)双端要使用一致的字符集来编解码，如:都是用Encoding.ASCII，Encoding.UTF8等。
3. 组播地址范围是224.0.0.0～239.255.255.255的D类IP地址是公网，万一和另一个人冲突了怎么办？？？
4. 西电导航里的群发通知，是使用udp的IP广播做的？？？还是IP组播？？还是广播+组播？？or别的方式？？
5. 单纯性P2P应用 == PNRP(使用资源名来获取IP + port) + 普通的TCP/UDP传输。但是像BT下载那样明显不是普通的TCP/UDP，使用切片-索引 + 从多个主机上接受，这不是相当于PnP了吗？？？


6. TCP/UDP不是能传输文件吗？？why还要专门定义一个FTP应用层协议来传文件。
	- TCP/UDP是传输层协议，他只提供了一种最基本的数据传输能力(因为他要保证common，故只支持传byte[])，但是应用层协议是一般都是针对于特定的需求设计的，应用层协议 = 传输层协议(能力) + 面各项任务的控制优化


7. 我觉得应用层协议的学习 不同于 传输层以下的TCP/IP协议栈的学习。
	- TCP/IP协议栈是一个简单纯粹的、通用的东西，它就像一个管道，他的学习就是单纯的搞懂裸数据传输的机制就可以。
	- 而应用层协议都是基于TCP/IP协议栈 + 对于特定需求的优化，学习他们我们需要进行对比学习来掌握应用层协议为什么这么设计的本质，不搞懂__为什么非他不可__其实就没有搞懂应用层协议。如：
		1. why 文件传输方面 FTP 比 HTTP SMTP更高效？？
		2. why 邮件收发方面 SMTP比 HTTP FTP更高效？？ 邮件本身不也是文件吗？？why不能用FTP非要在弄一个？？
		3. why Web页面文档的传输方面 HTTP比 FTP SMTP更高效？？Web页面本身不也是(Html + css + js)文件？？？ why不直接使用FTP来传
			- 因为 超文本 != 普通文本，超文本多了一些特点，针对这些特点可以做专门的与优化。


8. 结合C版本的从零搭建一个HTTP服务器 + C#网络书里的HTTP部分 + 小林的图解网络的HTTP部分 ->弄明白HTTP的本质，并搭建出我的HTTP服务器，给Unity后端做服务 

9. GET POST方法是 "安全"(http中指请求方法不会破坏服务器上的资源) “幂等”(多次执行相同的操作，结果都是相通的) 的吗？？？ 安全-幂等为什么很重要？？？
	1. GET是安全-幂等的，因为他是只读的操作
	2. POST是非安全-非幂等的

10. 为什么HTTP/1.1在Hearder和Body之间需要插入一行 \r\n（即，一个空行）？？？
	- 总来分割定位的？？？普通的每一行的结尾都是\r\n，但是在Heaader的最后一行的结尾是\r\n \r\n。

11. why HTTP/1.0中的串行阻塞 -> 队头阻塞 和 HTTP/2.0的TCP的丢失重传->all 基于同一tcp的all http均阻塞。是不是说明，HTTP/2.0改进的只是假设TCP不出现丢失-重传时，单纯的某一次的时间太长的请求-应答过程给他提前未完成就先提前返回，把下层TCP的使用权先交给下一个http任务，即这种对tcp的复用是像时间片轮转的那种伪并发？？？最小粒度不同http任务的切换是，上一个http不管是不是提前结束都要有始有终(即要收到应答，不能丢包），如果发生了丢包就没法切换了，因为如果此时强行切换这个丢包的http可能就乱套了，故仍会阻塞等待当前http收到然后才能切换。
## .NET的学习
### OpenFileDialog类

